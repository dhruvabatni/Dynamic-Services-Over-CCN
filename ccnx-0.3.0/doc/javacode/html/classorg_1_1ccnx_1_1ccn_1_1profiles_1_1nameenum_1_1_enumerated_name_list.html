<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Content-Centric Networking in Java: org.ccnx.ccn.profiles.nameenum.EnumeratedNameList Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>org</b>.<b>ccnx</b>.<b>ccn</b>.<b>profiles</b>.<b>nameenum</b>.<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html">EnumeratedNameList</a>
  </div>
</div>
<div class="contents">
<h1>org.ccnx.ccn.profiles.nameenum.EnumeratedNameList Class Reference</h1><!-- doxytag: class="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList" --><!-- doxytag: inherits="org::ccnx::ccn::profiles::nameenum::BasicNameEnumeratorListener" -->
<p>Blocking and background interface to name enumeration.  
<a href="#_details">More...</a></p>

<p><a href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>NewChildrenByThread</b></td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a446e659b2b1f65a252ece23075aa832d">EnumeratedNameList</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> namePrefix, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html" title="Blocking and background interface to name enumeration.">EnumeratedNameList</a> object.  <a href="#a446e659b2b1f65a252ece23075aa832d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a648bb922a1182f2004628f00d6f6f37e"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::EnumeratedNameList" ref="a648bb922a1182f2004628f00d6f6f37e" args="(ContentName namePrefix, boolean startEnumerating, CCNHandle handle)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><b>EnumeratedNameList</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> namePrefix, boolean startEnumerating, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a7dc14995a6990e3622e41a0014507a55">getName</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method to return the ContentName used for enumeration.  <a href="#a7dc14995a6990e3622e41a0014507a55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">synchronized void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a0ab483086bfc2a81f555c3b35252ad1a">stopEnumerating</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cancels ongoing name enumeration.  <a href="#a0ab483086bfc2a81f555c3b35252ad1a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">synchronized void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#ad7d037e76fa15924ab07112610be5a10">startEnumerating</a> ()  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts enumeration, if we're not enumerating already.  <a href="#ad7d037e76fa15924ab07112610be5a10"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2bbcea8ce6e7412aa291d2ef19a30d3c"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::isEnumerating" ref="a2bbcea8ce6e7412aa291d2ef19a30d3c" args="()" -->
boolean&nbsp;</td><td class="memItemRight" valign="bottom"><b>isEnumerating</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2581acd4ce5cb5c38ceb541c07043093"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::hasEnumerated" ref="a2581acd4ce5cb5c38ceb541c07043093" args="()" -->
boolean&nbsp;</td><td class="memItemRight" valign="bottom"><b>hasEnumerated</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a954a15620fdf9860963ba901bdc2357d"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::shutdown" ref="a954a15620fdf9860963ba901bdc2357d" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a954a15620fdf9860963ba901bdc2357d">shutdown</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shutdown anybody waiting for children on this list. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortedSet&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a36db5418c3e47896bf413f22ef4ea988">getNewData</a> (boolean threadPoolContext, long timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface to retrieve only new data from enumeration responses as it arrives.  <a href="#a36db5418c3e47896bf413f22ef4ea988"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortedSet&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#ae791088b591d432a1b8d873e63205223">getNewData</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block and wait as long as it takes for new data to appear.  <a href="#ae791088b591d432a1b8d873e63205223"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortedSet&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a1021eb447696c4b64912ccf96fe6a1f7">getNewData</a> (long timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block and wait for timeout or until new data appears.  <a href="#a1021eb447696c4b64912ccf96fe6a1f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortedSet&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a1514d3cd7a405697bdd9e062b9158ec6">getNewDataThreadPool</a> (long timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Block and wait for timeout or until new data appears.  <a href="#a1514d3cd7a405697bdd9e062b9158ec6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">SortedSet&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#adcc1315de0e2fd28f1b2415035f8e607">getChildren</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns single-component ContentName objects containing the name components of the children.  <a href="#adcc1315de0e2fd28f1b2415035f8e607"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a485bc1e23bbb44700a15f9eeddc06ed8">hasNewData</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the prefix has new names that have not been handled by the calling application.  <a href="#a485bc1e23bbb44700a15f9eeddc06ed8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#aecb70cff86bf9540986741fc37338148">hasChildren</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if we have received any responses listing available child names.  <a href="#aecb70cff86bf9540986741fc37338148"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68fa02ca7f1f6f2b6722ff22e59f9d2f"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::childCount" ref="a68fa02ca7f1f6f2b6722ff22e59f9d2f" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a68fa02ca7f1f6f2b6722ff22e59f9d2f">childCount</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of children we have, or 0 if we have none. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#ad3af24415fb8ce25b113725854486708">hasChild</a> (byte[] childComponent)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if we know the prefix has a child matching the given name component.  <a href="#ad3af24415fb8ce25b113725854486708"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a8e787e4125bbafe947fa844ee76c1ecf">hasChild</a> (String childName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether a child is present in the list of known children.  <a href="#a8e787e4125bbafe947fa844ee76c1ecf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a2c345faa236073741cb8d45f4dd097af">waitForNewChildren</a> (boolean threadPoolContext, long timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for new children to arrive.  <a href="#a2c345faa236073741cb8d45f4dd097af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#aa7695fe4bfc76b012e0cf36c0a806ec9">waitForNewChildren</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for new children to arrive.  <a href="#aa7695fe4bfc76b012e0cf36c0a806ec9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a98d44bad1b78c53e819174311c5e736d">waitForNewChildren</a> (long timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for new children to arrive.  <a href="#a98d44bad1b78c53e819174311c5e736d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#ab99d63e9b6273a824e2aa935335c28bd">waitForNewChildrenThreadPool</a> (long timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for new children to arrive in thread pool context.  <a href="#ab99d63e9b6273a824e2aa935335c28bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#ac4aa242053b9307a352b351e704a2e44">waitForChildren</a> (long timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits until there is any data at all.  <a href="#ac4aa242053b9307a352b351e704a2e44"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a94344c00f223c476299e2f5188425c76">waitForChildren</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait (block) for initial data to arrive, possibly forever.  <a href="#a94344c00f223c476299e2f5188425c76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a99f86c2e59b981bf6ba2cd10b45560e1">waitForNoUpdates</a> (long timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for new children to arrive until there is a period of length timeout during which no new child arrives.  <a href="#a99f86c2e59b981bf6ba2cd10b45560e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a4c3569a894332d87556d3053ce6d3d0f">waitForNoUpdatesOrResult</a> (long timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for new children to arrive until there is a period of length timeout during which no new child arrives, or the method <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#af593f0d16a23fc8b8488487e6fce7c81" title="Subclasses should override this test to answer true if waiters should break out of...">hasResult()</a> returns true.  <a href="#a4c3569a894332d87556d3053ce6d3d0f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#af593f0d16a23fc8b8488487e6fce7c81">hasResult</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subclasses should override this <a class="el" href="namespaceorg_1_1ccnx_1_1ccn_1_1test.html" title="PD org.ccnx.ccn.test.">test</a> to answer true if waiters should break out of a waitForNoUpdatesOrResult loop.  <a href="#af593f0d16a23fc8b8488487e6fce7c81"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a080660e6b9df566eb00f3e7541c7306d">clearResult</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset whatever state hasResult tests.  <a href="#a080660e6b9df566eb00f3e7541c7306d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a6636ed80ae09394e4ca6c62cee68954e">getLatestVersionChildName</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If some or all of the children of this name are versions, returns the latest version among them.  <a href="#a6636ed80ae09394e4ca6c62cee68954e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a7137e88e7e3bd017f6635c35fa3cf0d2">handleNameEnumerator</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> prefix, ArrayList&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> &gt; names)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handle responses from <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_c_c_n_name_enumerator.html" title="Implements the base Name Enumerator.">CCNNameEnumerator</a> that give us a list of single-component child names.  <a href="#a7137e88e7e3bd017f6635c35fa3cf0d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a06111d0a1674f9e4f6cc4e6ea959577f">getLatestVersionChildNameComponent</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the latest version available under this prefix as a byte array.  <a href="#a06111d0a1674f9e4f6cc4e6ea959577f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a9c4e77b4bf31001fb369c463ff9ed5b4">getLatestVersionChildTime</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the latest version available under this prefix as a CCNTime object.  <a href="#a9c4e77b4bf31001fb369c463ff9ed5b4"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a9db6a7ca3a8d0567658030f9a4ef7024">getLatestVersionName</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> name, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A static method that performs a one-shot call that returns the complete name of the latest version of content with the given prefix.  <a href="#a9db6a7ca3a8d0567658030f9a4ef7024"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html">EnumeratedNameList</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#acdbb684e114a82e2d7b0472d66700eb9">exists</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> childName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> prefixKnownToExist, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Static method that iterates down the namespace starting with the supplied prefix as a ContentName (prefixKnownToExist) to a specific child (childName).  <a href="#acdbb684e114a82e2d7b0472d66700eb9"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#af4a3788566079cc7a51622a108be2ffc">processNewChildren</a> (SortedSet&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> &gt; newChildren)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method to allow subclasses to do post-processing on incoming names before handing them to customers.  <a href="#af4a3788566079cc7a51622a108be2ffc"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace9fd983e183e661df36a8ead96f4625"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::_namePrefix" ref="ace9fd983e183e661df36a8ead96f4625" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>_namePrefix</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa85f8ac0b65a74c4aa3aa50ae2b0f0bb"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::_enumerator" ref="aa85f8ac0b65a74c4aa3aa50ae2b0f0bb" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_c_c_n_name_enumerator.html">CCNNameEnumerator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>_enumerator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5054f7d24cd11f923d427ff223da33cd"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::callback" ref="a5054f7d24cd11f923d427ff223da33cd" args="" -->
<a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_basic_name_enumerator_listener.html">BasicNameEnumeratorListener</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>callback</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4c43be6aaa2c04cd1ef586e894798d4"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::_children" ref="af4c43be6aaa2c04cd1ef586e894798d4" args="" -->
SortedSet&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>_children</b> = new TreeSet&lt;<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&gt;()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2438e298f995d7a5d9a53b013024e621"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::_newChildrenByThread" ref="a2438e298f995d7a5d9a53b013024e621" args="" -->
Map&lt; Long, NewChildrenByThread &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>_newChildrenByThread</b> = new TreeMap&lt;Long, NewChildrenByThread&gt;()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af686bed5669f14099f75ae1160ff76f4"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::_childLock" ref="af686bed5669f14099f75ae1160ff76f4" args="" -->
Object&nbsp;</td><td class="memItemRight" valign="bottom"><b>_childLock</b> = new Object()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad07e77d93dc90938da8f406dc8db6798"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::_lastUpdate" ref="ad07e77d93dc90938da8f406dc8db6798" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>_lastUpdate</b> = null</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3a0469156ce01497d589c9bc682608cb"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::_enumerating" ref="a3a0469156ce01497d589c9bc682608cb" args="" -->
boolean&nbsp;</td><td class="memItemRight" valign="bottom"><b>_enumerating</b> = false</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5a982deb01da9f0278c3ff3af6e871c"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::_shutdown" ref="aa5a982deb01da9f0278c3ff3af6e871c" args="" -->
boolean&nbsp;</td><td class="memItemRight" valign="bottom"><b>_shutdown</b> = false</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a966090eeaed8be5d5d16d6803c37a4c5">_hasEnumerated</a> = false</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Keep track of whether we've ever done enumeration, so we can start it automatically if someone asks us for something not in our cache.  <a href="#a966090eeaed8be5d5d16d6803c37a4c5"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Blocking and background interface to name enumeration. </p>
<p>This allows a caller to specify a prefix under which to enumerate available children, and name enumeration to proceed in the background for as long as desired, providing updates whenever new data is published. Currently implemented as a wrapper around <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_c_c_n_name_enumerator.html" title="Implements the base Name Enumerator.">CCNNameEnumerator</a>, will likely directly aggregate name enumeration responses in the future.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_c_c_n_name_enumerator.html" title="Implements the base Name Enumerator.">CCNNameEnumerator</a> </dd>
<dd>
<a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_basic_name_enumerator_listener.html" title="Interface for classes making name enumeration requests to allow callbacks with content...">BasicNameEnumeratorListener</a> </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a446e659b2b1f65a252ece23075aa832d"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::EnumeratedNameList" ref="a446e659b2b1f65a252ece23075aa832d" args="(ContentName namePrefix, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.EnumeratedNameList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>namePrefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html" title="Blocking and background interface to name enumeration.">EnumeratedNameList</a> object. </p>
<p>This constructor creates a new <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html" title="Blocking and background interface to name enumeration.">EnumeratedNameList</a> object that will begin enumerating the children of the specified prefix. The new <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html" title="Blocking and background interface to name enumeration.">EnumeratedNameList</a> will use the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html" title="The core class encapsulating a Java interface to the CCN network.">CCNHandle</a> passed in to the constructor, or create a new one using <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#abbbf4626e10f2d1a2addd1dc5b6a069f" title="Create a new CCNHandle, opening a new connection to the CCN network.">CCNHandle.open()</a> if it is null.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>namePrefix</em>&nbsp;</td><td>the ContentName whose children we wish to list. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html" title="The core class encapsulating a Java interface to the CCN network.">CCNHandle</a> object for sending interests and receiving content object responses. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a080660e6b9df566eb00f3e7541c7306d"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::clearResult" ref="a080660e6b9df566eb00f3e7541c7306d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.clearResult </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reset whatever state hasResult tests. </p>
<p>Overridden by subclasses, default does nothing. </p>

</div>
</div>
<a class="anchor" id="acdbb684e114a82e2d7b0472d66700eb9"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::exists" ref="acdbb684e114a82e2d7b0472d66700eb9" args="(ContentName childName, ContentName prefixKnownToExist, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html">EnumeratedNameList</a> org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.exists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>childName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>prefixKnownToExist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException <code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Static method that iterates down the namespace starting with the supplied prefix as a ContentName (prefixKnownToExist) to a specific child (childName). </p>
<p>The method returns null if the name does not exist in a limited time iteration. If the child is found, this method returns the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html" title="Blocking and background interface to name enumeration.">EnumeratedNameList</a> object for the parent of the desired child in the namespace. The current implementation may time out before the desired name is found. Additionally, the current implementation does not loop on an enumeration attempt, so a child may be missed if it is not included in the first enumeration response.</p>
<p>TODO Add loop to enumerate under a name multiple times to avoid missing a child name TODO Handle timeouts better to avoid missing children. (Note: We could modify the name enumeration protocol to return empty responses if we query for an unknown name, but that adds semantic complications.)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>childName</em>&nbsp;</td><td>ContentName for the child we are looking for under (does not have to be directly under) a given prefix. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>prefixKnownToExist</em>&nbsp;</td><td>ContentName prefix to enumerate to look for a given child. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html" title="The core class encapsulating a Java interface to the CCN network.">CCNHandle</a> for sending and receiving interests and content objects.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html" title="Blocking and background interface to name enumeration.">EnumeratedNameList</a> Returns the parent <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html" title="Blocking and background interface to name enumeration.">EnumeratedNameList</a> for the desired child, if one is found. Returns null if the child is not found.</dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adcc1315de0e2fd28f1b2415035f8e607"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::getChildren" ref="adcc1315de0e2fd28f1b2415035f8e607" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortedSet&lt;<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&gt; org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.getChildren </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns single-component ContentName objects containing the name components of the children. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>SortedSet&lt;ContentName&gt; Returns the array of single-component content name children that have been retrieved so far, or null if no responses have yet been received. The latter may indicate either that no children of this prefix are known to any responders, or that they have not had time to respond. </dd></dl>

</div>
</div>
<a class="anchor" id="a6636ed80ae09394e4ca6c62cee68954e"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::getLatestVersionChildName" ref="a6636ed80ae09394e4ca6c62cee68954e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.getLatestVersionChildName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If some or all of the children of this name are versions, returns the latest version among them. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>ContentName The latest version component </dd></dl>

</div>
</div>
<a class="anchor" id="a06111d0a1674f9e4f6cc4e6ea959577f"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::getLatestVersionChildNameComponent" ref="a06111d0a1674f9e4f6cc4e6ea959577f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte [] org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.getLatestVersionChildNameComponent </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the latest version available under this prefix as a byte array. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>byte[] Latest child version as byte array </dd></dl>

</div>
</div>
<a class="anchor" id="a9c4e77b4bf31001fb369c463ff9ed5b4"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::getLatestVersionChildTime" ref="a9c4e77b4bf31001fb369c463ff9ed5b4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a> org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.getLatestVersionChildTime </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the latest version available under this prefix as a CCNTime object. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>CCNTime Latest child version as CCNTime </dd></dl>

</div>
</div>
<a class="anchor" id="a9db6a7ca3a8d0567658030f9a4ef7024"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::getLatestVersionName" ref="a9db6a7ca3a8d0567658030f9a4ef7024" args="(ContentName name, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.getLatestVersionName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException <code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A static method that performs a one-shot call that returns the complete name of the latest version of content with the given prefix. </p>
<p>An alternative route to finding the name of the latest version of a piece of content, rather than using methods in the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_versioning_profile.html" title="Versions, when present, usually occupy the penultimate component of the CCN name...">VersioningProfile</a> to retrieve an arbitrary block of content under that version. Useful when the data under a version is complex in structure.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>ContentName to find the latest version of </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html" title="The core class encapsulating a Java interface to the CCN network.">CCNHandle</a> to use for enumeration </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ContentName The name supplied to the call with the latest version added. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7dc14995a6990e3622e41a0014507a55"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::getName" ref="a7dc14995a6990e3622e41a0014507a55" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.getName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Method to return the ContentName used for enumeration. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>ContentName returns the prefix under which we are enumerating children. </dd></dl>

</div>
</div>
<a class="anchor" id="a1021eb447696c4b64912ccf96fe6a1f7"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::getNewData" ref="a1021eb447696c4b64912ccf96fe6a1f7" args="(long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortedSet&lt;<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&gt; org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.getNewData </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Block and wait for timeout or until new data appears. </p>
<p>See <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a36db5418c3e47896bf413f22ef4ea988" title="Interface to retrieve only new data from enumeration responses as it arrives.">getNewData(boolean, long)</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>in ms </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SortedSet&lt;ContentName&gt; Returns the array of single-component content name children that are new to us, or null if we reached the timeout before new data arrived </dd></dl>

</div>
</div>
<a class="anchor" id="ae791088b591d432a1b8d873e63205223"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::getNewData" ref="ae791088b591d432a1b8d873e63205223" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortedSet&lt;<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&gt; org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.getNewData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Block and wait as long as it takes for new data to appear. </p>
<p>See <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a36db5418c3e47896bf413f22ef4ea988" title="Interface to retrieve only new data from enumeration responses as it arrives.">getNewData(boolean, long)</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>SortedSet&lt;ContentName&gt; Returns the array of single-component content name children that are new to us. Waits forever if no new data appears </dd></dl>

</div>
</div>
<a class="anchor" id="a36db5418c3e47896bf413f22ef4ea988"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::getNewData" ref="a36db5418c3e47896bf413f22ef4ea988" args="(boolean threadPoolContext, long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortedSet&lt;<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&gt; org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.getNewData </td>
          <td>(</td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>threadPoolContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Interface to retrieve only new data from enumeration responses as it arrives. </p>
<p>This method blocks and waits for data, but grabs the new data for processing. In threadPoolContext it will in effect remove the data from every other listener who is listening in threadPoolContext, in effect handing the new children to the first consumer to wake up and make the other ones go around again. There is currently no support for more than one simultaneous thread pool.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>threadPoolContext</em>&nbsp;</td><td>Are we getting data in threadPoolContext? (described above). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>maximum amount of time to wait, 0 to wait forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SortedSet&lt;ContentName&gt; Returns the array of single-component content name children that are new to us, or null if we reached the timeout before new data arrived </dd></dl>

</div>
</div>
<a class="anchor" id="a1514d3cd7a405697bdd9e062b9158ec6"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::getNewDataThreadPool" ref="a1514d3cd7a405697bdd9e062b9158ec6" args="(long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SortedSet&lt;<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&gt; org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.getNewDataThreadPool </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Block and wait for timeout or until new data appears. </p>
<p>See <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a36db5418c3e47896bf413f22ef4ea988" title="Interface to retrieve only new data from enumeration responses as it arrives.">getNewData(boolean, long)</a>. Different from getNewData in that new data is shared among all threads accessing this instance of <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html" title="Blocking and background interface to name enumeration.">EnumeratedNameList</a>. So if another thread gets the data first, we won't get it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>in ms </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>SortedSet&lt;ContentName&gt; Returns the array of single-component content name children that are new to the list instance if we got it first, or null if we reached the timeout before new data arrived </dd></dl>

</div>
</div>
<a class="anchor" id="a7137e88e7e3bd017f6635c35fa3cf0d2"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::handleNameEnumerator" ref="a7137e88e7e3bd017f6635c35fa3cf0d2" args="(ContentName prefix, ArrayList&lt; ContentName &gt; names)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.handleNameEnumerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayList&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>names</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handle responses from <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_c_c_n_name_enumerator.html" title="Implements the base Name Enumerator.">CCNNameEnumerator</a> that give us a list of single-component child names. </p>
<p>Filter out the names new to us, add them to our list of known children, postprocess them with <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#af4a3788566079cc7a51622a108be2ffc" title="Method to allow subclasses to do post-processing on incoming names before handing...">processNewChildren(SortedSet&lt;ContentName&gt;)</a>, and signal waiters if we have new data.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>prefix</em>&nbsp;</td><td>Prefix used for name enumeration. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>names</em>&nbsp;</td><td>The list of names returned in this name enumeration response.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>int </dd></dl>

<p>Implements <a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_basic_name_enumerator_listener.html#a2d77481bcc248d1ef479fc25dcc7e942">org.ccnx.ccn.profiles.nameenum.BasicNameEnumeratorListener</a>.</p>

</div>
</div>
<a class="anchor" id="a8e787e4125bbafe947fa844ee76c1ecf"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::hasChild" ref="a8e787e4125bbafe947fa844ee76c1ecf" args="(String childName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.hasChild </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>childName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether a child is present in the list of known children. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>childName</em>&nbsp;</td><td>String version of a child name to look for </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>boolean Returns true if the name is present in the list of known children. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3af24415fb8ce25b113725854486708"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::hasChild" ref="ad3af24415fb8ce25b113725854486708" args="(byte[] childComponent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.hasChild </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>childComponent</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if we know the prefix has a child matching the given name component. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>childComponent</em>&nbsp;</td><td>name component to check for in the stored child names. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if that child is in our list of known children </dd></dl>

</div>
</div>
<a class="anchor" id="aecb70cff86bf9540986741fc37338148"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::hasChildren" ref="aecb70cff86bf9540986741fc37338148" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.hasChildren </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if we have received any responses listing available child names. </p>
<p>If no names have yet been received, this may mean either that responses have not had time to arrive, or there are know children known to available responders.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if we have child names received from enumeration responses </dd></dl>

</div>
</div>
<a class="anchor" id="a485bc1e23bbb44700a15f9eeddc06ed8"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::hasNewData" ref="a485bc1e23bbb44700a15f9eeddc06ed8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.hasNewData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the prefix has new names that have not been handled by the calling application. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if there are new children available to process </dd></dl>

</div>
</div>
<a class="anchor" id="af593f0d16a23fc8b8488487e6fce7c81"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::hasResult" ref="af593f0d16a23fc8b8488487e6fce7c81" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.hasResult </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subclasses should override this <a class="el" href="namespaceorg_1_1ccnx_1_1ccn_1_1test.html" title="PD org.ccnx.ccn.test.">test</a> to answer true if waiters should break out of a waitForNoUpdatesOrResult loop. </p>
<p>Note that results must be cleared manually using clearResult. Default behavior always returns false. Subclasses probably want to set a variable in processNewChildren that will be read here. </p>

<p>Reimplemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#aa4b33408f39ce07f6a514e8ddd6ba9e6">org.ccnx.ccn.profiles.security.access.group.KeyDirectory</a>.</p>

</div>
</div>
<a class="anchor" id="af4a3788566079cc7a51622a108be2ffc"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::processNewChildren" ref="af4a3788566079cc7a51622a108be2ffc" args="(SortedSet&lt; ContentName &gt; newChildren)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.processNewChildren </td>
          <td>(</td>
          <td class="paramtype">SortedSet&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> &gt;&nbsp;</td>
          <td class="paramname"> <em>newChildren</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Method to allow subclasses to do post-processing on incoming names before handing them to customers. </p>
<p>Note that the set handed in here is not the set that will be handed out; only the name objects are the same.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newChildren</em>&nbsp;</td><td>SortedSet of children available for processing</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

<p>Reimplemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a84b2491ca200cd9b51e39e2aef467797">org.ccnx.ccn.profiles.security.access.group.KeyDirectory</a>.</p>

</div>
</div>
<a class="anchor" id="ad7d037e76fa15924ab07112610be5a10"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::startEnumerating" ref="ad7d037e76fa15924ab07112610be5a10" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">synchronized void org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.startEnumerating </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts enumeration, if we're not enumerating already. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0ab483086bfc2a81f555c3b35252ad1a"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::stopEnumerating" ref="a0ab483086bfc2a81f555c3b35252ad1a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">synchronized void org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.stopEnumerating </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cancels ongoing name enumeration. </p>
<p>Previously-accumulated information about children of this name are still stored and available for use.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a94344c00f223c476299e2f5188425c76"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::waitForChildren" ref="a94344c00f223c476299e2f5188425c76" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.waitForChildren </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait (block) for initial data to arrive, possibly forever. </p>
<p>See waitForData(long).</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="ac4aa242053b9307a352b351e704a2e44"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::waitForChildren" ref="ac4aa242053b9307a352b351e704a2e44" args="(long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.waitForChildren </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits until there is any data at all. </p>
<p>Right now, waits for the first response containing actual children, not just a name enumeration response. That means it could block forever if no children exist in a repository or there are not any applications responding to name enumeration requests. Once we have an initial set of children, this method returns immediately.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Maximum amount of time to wait, if 0, waits forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a98d44bad1b78c53e819174311c5e736d"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::waitForNewChildren" ref="a98d44bad1b78c53e819174311c5e736d" args="(long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.waitForNewChildren </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for new children to arrive. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Maximum amount of time to wait, if 0, waits forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a boolean value that indicates whether new data was found. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7695fe4bfc76b012e0cf36c0a806ec9"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::waitForNewChildren" ref="aa7695fe4bfc76b012e0cf36c0a806ec9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.waitForNewChildren </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for new children to arrive. </p>
<p>This method does not have a timeout and will wait forever.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>void </dd></dl>

</div>
</div>
<a class="anchor" id="a2c345faa236073741cb8d45f4dd097af"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::waitForNewChildren" ref="a2c345faa236073741cb8d45f4dd097af" args="(boolean threadPoolContext, long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.waitForNewChildren </td>
          <td>(</td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>threadPoolContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for new children to arrive. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Maximum time to wait for new data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threadPoolContext</em>&nbsp;</td><td>Are we waiting in threadPoolContext (i.e. other threads can grab children first) See <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a36db5418c3e47896bf413f22ef4ea988" title="Interface to retrieve only new data from enumeration responses as it arrives.">getNewData(boolean, long)</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a boolean value that indicates whether new data was found. </dd></dl>

</div>
</div>
<a class="anchor" id="ab99d63e9b6273a824e2aa935335c28bd"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::waitForNewChildrenThreadPool" ref="ab99d63e9b6273a824e2aa935335c28bd" args="(long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.waitForNewChildrenThreadPool </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for new children to arrive in thread pool context. </p>
<p>See notes about this above. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Maximum amount of time to wait, if 0, waits forever. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>a boolean value that indicates whether new data was found. </dd></dl>

</div>
</div>
<a class="anchor" id="a99f86c2e59b981bf6ba2cd10b45560e1"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::waitForNoUpdates" ref="a99f86c2e59b981bf6ba2cd10b45560e1" args="(long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.waitForNoUpdates </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for new children to arrive until there is a period of length timeout during which no new child arrives. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>The maximum amount of time to wait between consecutive children arrivals. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c3569a894332d87556d3053ce6d3d0f"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::waitForNoUpdatesOrResult" ref="a4c3569a894332d87556d3053ce6d3d0f" args="(long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.profiles.nameenum.EnumeratedNameList.waitForNoUpdatesOrResult </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for new children to arrive until there is a period of length timeout during which no new child arrives, or the method <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#af593f0d16a23fc8b8488487e6fce7c81" title="Subclasses should override this test to answer true if waiters should break out of...">hasResult()</a> returns true. </p>
<p>The expectation is that a subclass will monitor incoming updates in its <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#af4a3788566079cc7a51622a108be2ffc" title="Method to allow subclasses to do post-processing on incoming names before handing...">processNewChildren()</a> override method, and in that method, set some sort of flag that will be tested by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#af593f0d16a23fc8b8488487e6fce7c81" title="Subclasses should override this test to answer true if waiters should break out of...">hasResult()</a>. Note that this method does not currently stop enumeration -- enumeration results will continue to accumulate in the background (and request interests will continue to be sent); callers must call <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a0ab483086bfc2a81f555c3b35252ad1a" title="Cancels ongoing name enumeration.">stopEnumerating()</a> to actually terminate enumeration. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a966090eeaed8be5d5d16d6803c37a4c5"></a><!-- doxytag: member="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList::_hasEnumerated" ref="a966090eeaed8be5d5d16d6803c37a4c5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#a966090eeaed8be5d5d16d6803c37a4c5">org.ccnx.ccn.profiles.nameenum.EnumeratedNameList._hasEnumerated</a> = false<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Keep track of whether we've ever done enumeration, so we can start it automatically if someone asks us for something not in our cache. </p>
<p>This lets us relax the requirement that callers pre-enumerate just in case. Can't use hasChildren; there might not be any children but we might have tried enumeration already. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/org/ccnx/ccn/profiles/nameenum/EnumeratedNameList.java</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Thu Nov 4 13:34:29 2010 for Content-Centric Networking in Java by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
