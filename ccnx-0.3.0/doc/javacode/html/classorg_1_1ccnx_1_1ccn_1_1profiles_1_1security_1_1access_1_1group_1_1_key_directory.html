<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Content-Centric Networking in Java: org.ccnx.ccn.profiles.security.access.group.KeyDirectory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>org</b>.<b>ccnx</b>.<b>ccn</b>.<b>profiles</b>.<b>security</b>.<b>access</b>.<b>group</b>.<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html">KeyDirectory</a>
  </div>
</div>
<div class="contents">
<h1>org.ccnx.ccn.profiles.security.access.group.KeyDirectory Class Reference</h1><!-- doxytag: class="org::ccnx::ccn::profiles::security::access::group::KeyDirectory" --><!-- doxytag: inherits="org::ccnx::ccn::profiles::nameenum::EnumeratedNameList" -->
<p>A key directory holds a key (secret or private), distributed to entities (represented by public keys), by a set of key blocks each of which wrapping that key under different target keys.  
<a href="#_details">More...</a></p>

<p><a href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a62bcf87a2cca5a19e609fb8399032857">KeyDirectory</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_group_access_control_manager.html">GroupAccessControlManager</a> manager, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> directoryName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Directory name should be versioned, else we pull the latest version; start enumeration.  <a href="#a62bcf87a2cca5a19e609fb8399032857"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#ac25d70b20cd73eb09114e80325437df3">KeyDirectory</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_group_access_control_manager.html">GroupAccessControlManager</a> manager, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> directoryName, boolean enumerate, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Directory name should be versioned, else we pull the latest version.  <a href="#ac25d70b20cd73eb09114e80325437df3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#aa4b33408f39ce07f6a514e8ddd6ba9e6">hasResult</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subclasses should override this <a class="el" href="namespaceorg_1_1ccnx_1_1ccn_1_1test.html" title="PD org.ccnx.ccn.test.">test</a> to answer true if waiters should break out of a waitForNoUpdatesOrResult loop.  <a href="#aa4b33408f39ce07f6a514e8ddd6ba9e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TreeSet&lt; byte[]&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a41b9807389292ac353f487730cbee700">getCopyOfWrappingKeyIDs</a> ()  throws ContentNotReadyException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a copy to avoid synchronization problems.  <a href="#a41b9807389292ac353f487730cbee700"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">HashMap&lt; String, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_group_access_control_profile_1_1_principal_info.html">PrincipalInfo</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a56f067275c0eb608ff620427459c3109">getCopyOfPrincipals</a> ()  throws ContentNotReadyException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a copy to avoid synchronization problems.  <a href="#a56f067275c0eb608ff620427459c3109"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_group_access_control_profile_1_1_principal_info.html">PrincipalInfo</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a90be6c833df9a0e7a1dcf5057490c4e5">getPrincipalInfo</a> (String principal)  throws ContentNotReadyException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns principal info.  <a href="#a90be6c833df9a0e7a1dcf5057490c4e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TreeSet&lt; byte[]&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#ae6e296be639397cef237e28cbda2d3a8">getCopyOfOtherNames</a> ()  throws ContentNotReadyException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a copy to avoid synchronization problems.  <a href="#ae6e296be639397cef237e28cbda2d3a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#abca4d663fe4c557dbdedcf9f538414c2">getWrappedKeyForKeyID</a> (byte[] keyID)  throws ContentDecodingException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the wrapped key object corresponding to a public key specified by its digest.  <a href="#abca4d663fe4c557dbdedcf9f538414c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a0795d18502c234dd973f33c1dbef4efe">getWrappedKeyNameForKeyID</a> (byte[] keyID)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the wrapped key name for a public key specified by its digest.  <a href="#a0795d18502c234dd973f33c1dbef4efe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#afe54f9c58f223652911f7ac5f2bd37e0">getWrappedKeyForPrincipal</a> (String principalName)  throws ContentNotReadyException, ContentDecodingException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the wrapped key object corresponding to a specified principal.  <a href="#afe54f9c58f223652911f7ac5f2bd37e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a0aa9ef728931bee3ea7569bd1407e504">getWrappedKeyNameForPrincipal</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_group_access_control_profile_1_1_principal_info.html">PrincipalInfo</a> pi)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the wrapped key name for a specified principal.  <a href="#a0aa9ef728931bee3ea7569bd1407e504"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#ad8a430f9675cead22131f0e5a69c8e56">getWrappedKeyNameForPrincipal</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> principalPublicKeyName)  throws VersionMissingException, ContentEncodingException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the wrapped key name for a principal specified by the name of its public key.  <a href="#ad8a430f9675cead22131f0e5a69c8e56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#ae5785016391032e8ef33c67b5bc9a848">hasSupersededBlock</a> ()  throws ContentNotReadyException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for the existence of a superseded block.  <a href="#ae5785016391032e8ef33c67b5bc9a848"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5fd1b80f3d618825c0c37a109d1f324"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getSupersededBlockName" ref="af5fd1b80f3d618825c0c37a109d1f324" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getSupersededBlockName</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#ae40b202bb881fc1e96aad52f87e6acef">getSupersededWrappedKey</a> ()  throws ContentDecodingException, ContentNotReadyException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">We have several choices for how to represent superseded and previous keys.  <a href="#ae40b202bb881fc1e96aad52f87e6acef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#af3dc55a428ed2df0f27ac20087e92c23">getWrappedKey</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> wrappedKeyName)  throws ContentDecodingException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the wrapped key object corresponding to the specified wrapped key name.  <a href="#af3dc55a428ed2df0f27ac20087e92c23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a1625b43b02ba5fec51ded074ec5ce52d">hasPreviousKeyBlock</a> ()  throws ContentNotReadyException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks for the existence of a previous key block.  <a href="#a1625b43b02ba5fec51ded074ec5ce52d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8e68cc63ff79df75bbecf3f2d908e114"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getPreviousKeyBlockName" ref="a8e68cc63ff79df75bbecf3f2d908e114" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getPreviousKeyBlockName</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_link.html">Link</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#aeec7ea373078dd92176ade55f0712beb">getPreviousKey</a> (long timeout)  throws ContentNotReadyException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a link to the previous key.  <a href="#aeec7ea373078dd92176ade55f0712beb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a4239f4704d5229d55e2cda0440060c6d">hasPrivateKeyBlock</a> ()  throws ContentNotReadyException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">We store a private key as a single block wrapped under a nonce key, which is then wrapped under the public keys of various principals.  <a href="#a4239f4704d5229d55e2cda0440060c6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aadd03da3ffcff40e7139c13dc12c81ba"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getPrivateKeyBlockName" ref="aadd03da3ffcff40e7139c13dc12c81ba" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getPrivateKeyBlockName</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a2934b8470f59c87a26dd689aa8a8076c">getPrivateKeyObject</a> ()  throws ContentGoneException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the private key object, if one exists as a wrapped key object.  <a href="#a2934b8470f59c87a26dd689aa8a8076c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a7b4fc6ef3279410d712daa81011e9343">isUnwrappedKeyInCache</a> (byte[] expectedKeyID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Key&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a5d9472fe632ce3ebf99f5eefbde49b67">getUnwrappedKey</a> (byte[] expectedKeyID)  throws InvalidKeyException, ContentDecodingException, IOException, NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unwrap and return the key wrapped in a wrapping key specified by its digest.  <a href="#a5d9472fe632ce3ebf99f5eefbde49b67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Key&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#adf95e58412b70fb5a92c76f086da2738">unwrapKeyViaCache</a> (byte[] keyIDOfCachedKeytoUse)  throws ContentDecodingException, IOException, InvalidKeyException, NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Fast path -- once we have an idea which of our keys will unwrap this key, get it.  <a href="#adf95e58412b70fb5a92c76f086da2738"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9607c7a57c8c8aa3630edb9213fddc4"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::unwrapKeyViaCache" ref="ab9607c7a57c8c8aa3630edb9213fddc4" args="()" -->
Key&nbsp;</td><td class="memItemRight" valign="bottom"><b>unwrapKeyViaCache</b> ()  throws InvalidKeyException, ContentDecodingException, IOException, NoSuchAlgorithmException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab99c4e2e2f6910c55e2308969cedf292"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::unwrapKeyViaSupersededKey" ref="ab99c4e2e2f6910c55e2308969cedf292" args="()" -->
Key&nbsp;</td><td class="memItemRight" valign="bottom"><b>unwrapKeyViaSupersededKey</b> ()  throws InvalidKeyException, ContentDecodingException, IOException, NoSuchAlgorithmException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ae20bbd2aefce9137e4347777bc310a"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::unwrapKeyViaKnownGroupMembership" ref="a2ae20bbd2aefce9137e4347777bc310a" args="()" -->
Key&nbsp;</td><td class="memItemRight" valign="bottom"><b>unwrapKeyViaKnownGroupMembership</b> ()  throws InvalidKeyException, ContentDecodingException, IOException, NoSuchAlgorithmException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f39480d15f20238f3e761d560188909"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::unwrapKeyViaNotKnownGroupMembership" ref="a9f39480d15f20238f3e761d560188909" args="()" -->
Key&nbsp;</td><td class="memItemRight" valign="bottom"><b>unwrapKeyViaNotKnownGroupMembership</b> ()  throws InvalidKeyException, ContentDecodingException, IOException, NoSuchAlgorithmException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#ae1a2d952abf2404ee45245ffafb7ee2d">isPrivateKeyInCache</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">PrivateKey&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a555e24fe63aaf6175e2f2cc88da82c7a">getPrivateKey</a> ()  throws AccessDeniedException, InvalidKeyException,  	ContentNotReadyException, ContentGoneException, ContentDecodingException,  	IOException, NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the private key stored in the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html" title="A key directory holds a key (secret or private), distributed to entities (represented...">KeyDirectory</a>.  <a href="#a555e24fe63aaf6175e2f2cc88da82c7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a30c9b06a64136a0d99db4a41dfb20615">addWrappedKeyBlock</a> (Key secretKeyToWrap, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> publicKeyName, PublicKey publicKey)  throws ContentEncodingException, IOException, InvalidKeyException, VersionMissingException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a wrapped key block to the repository.  <a href="#a30c9b06a64136a0d99db4a41dfb20615"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a582e7c208735ce467f0640782f3335a5">addPrivateKeyBlock</a> (PrivateKey privateKey, Key privateKeyWrappingKey)  throws ContentEncodingException, IOException, InvalidKeyException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a private key block to the repository.  <a href="#a582e7c208735ce467f0640782f3335a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#aa9a8ad0d5e599fcfae281179430d6ff5">addSupersededByBlock</a> (Key oldPrivateKeyWrappingKey, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> storedSupersedingKeyName, byte[] storedSupersedingKeyID, Key newPrivateKeyWrappingKey)  throws InvalidKeyException, ContentEncodingException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a superseded-by block to our key directory.  <a href="#aa9a8ad0d5e599fcfae281179430d6ff5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a769dda93f706af17dcf1e170eeb62fc5">addPreviousKeyLink</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> previousKey, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_i_d.html">PublisherID</a> previousKeyPublisher)  throws ContentEncodingException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a link to a previous key to the repository.  <a href="#a769dda93f706af17dcf1e170eeb62fc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a9e6f2e6e868fab4fca48878e4f1a1d63">addPreviousKeyBlock</a> (Key oldPrivateKeyWrappingKey, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> supersedingKeyName, Key newPrivateKeyWrappingKey)  throws InvalidKeyException, ContentEncodingException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a previous key block to the repository.  <a href="#a9e6f2e6e868fab4fca48878e4f1a1d63"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6508c4d462f85a4bbd60efe398aac1c"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getSupersededBlockNameForKey" ref="ad6508c4d462f85a4bbd60efe398aac1c" args="(ContentName versionedKeyName)" -->
static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getSupersededBlockNameForKey</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> versionedKeyName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a98f94b3e2e18a35bd636adb620903082"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getPreviousKeyBlockName" ref="a98f94b3e2e18a35bd636adb620903082" args="(ContentName keyDirectoryName)" -->
static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getPreviousKeyBlockName</b> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> keyDirectoryName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#ac9c7cc6520e2d970d6746c9ed8a7a603">addSupersededByBlock</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> oldKeyVersionedNameToAddBlockTo, Key oldKeyToBeSuperseded, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> storedSupersedingKeyName, byte[] storedSupersedingKeyID, Key supersedingKey, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws ContentEncodingException, IOException, InvalidKeyException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a superseded-by block to another node key, where we may have only its name, not its enumeration.  <a href="#ac9c7cc6520e2d970d6746c9ed8a7a603"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#ae0ea55e6f0b181ebec43daeb00700255">initialize</a> (boolean startEnumerating)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">We don't start enumerating until we get here.  <a href="#ae0ea55e6f0b181ebec43daeb00700255"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a84b2491ca200cd9b51e39e2aef467797"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::processNewChildren" ref="a84b2491ca200cd9b51e39e2aef467797" args="(SortedSet&lt; ContentName &gt; newChildren)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a84b2491ca200cd9b51e39e2aef467797">processNewChildren</a> (SortedSet&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> &gt; newChildren)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called each time new data comes in, gets to parse it and load processed arrays. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a8053387680e34fbbb9f61f962e98ad1c">addPrincipal</a> (byte[] wkChildName)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a principal name.  <a href="#a8053387680e34fbbb9f61f962e98ad1c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Key&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#a1fdd71f8730b82e0e728883216e4666c">unwrapKeyForPrincipal</a> (String principal, Key unwrappingKey)  throws InvalidKeyException, ContentNotReadyException,  	ContentDecodingException, ContentGoneException, IOException, NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unwrap the key wrapped under a specified principal, with a specified unwrapping key.  <a href="#a1fdd71f8730b82e0e728883216e4666c"></a><br/></td></tr>
<tr><td colspan="2"><h2>Package Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae4a3c96a472b2e3d11f53c785ae4d84d"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::_handle" ref="ae4a3c96a472b2e3d11f53c785ae4d84d" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>_handle</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d213b7116aac1c717f3744849d874a6"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::_manager" ref="a9d213b7116aac1c717f3744849d874a6" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_group_access_control_manager.html">GroupAccessControlManager</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>_manager</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2861a9b0f61a690e62837f378be043a"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::cacheHit" ref="aa2861a9b0f61a690e62837f378be043a" args="" -->
boolean&nbsp;</td><td class="memItemRight" valign="bottom"><b>cacheHit</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3eb4e01419d13d67b40bee628ac6628"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::_principals" ref="af3eb4e01419d13d67b40bee628ac6628" args="" -->
HashMap&lt; String, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_group_access_control_profile_1_1_principal_info.html">PrincipalInfo</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#af3eb4e01419d13d67b40bee628ac6628">_principals</a> = new HashMap&lt;String, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_group_access_control_profile_1_1_principal_info.html">PrincipalInfo</a>&gt;()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maps the friendly names of principals (typically groups) to their information. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af0867f8ce78903de4b12baeeb5434114"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::_keyIDs" ref="af0867f8ce78903de4b12baeeb5434114" args="" -->
TreeSet&lt; byte[]&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#af0867f8ce78903de4b12baeeb5434114">_keyIDs</a> = new TreeSet&lt;byte []&gt;(byteArrayComparator)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The set _keyIDs contains the digests of the (public) wrapping keys of the wrapped key objects stored in the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html" title="A key directory holds a key (secret or private), distributed to entities (represented...">KeyDirectory</a>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdbfcd576cd79e0daffe3abdd8224e33"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::_otherNames" ref="abdbfcd576cd79e0daffe3abdd8224e33" args="" -->
TreeSet&lt; byte[]&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html#abdbfcd576cd79e0daffe3abdd8224e33">_otherNames</a> = new TreeSet&lt;byte []&gt;(byteArrayComparator)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The set _otherNames records the presence of superseded keys, previous keys, group private keys, etc. <br/></td></tr>
<tr><td colspan="2"><h2>Static Package Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0218a1e544901d7541f7685137c37bb"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::byteArrayComparator" ref="aa0218a1e544901d7541f7685137c37bb" args="" -->
static Comparator&lt; byte[]&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>byteArrayComparator</b> = new <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1support_1_1_byte_array_compare.html">ByteArrayCompare</a>()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A key directory holds a key (secret or private), distributed to entities (represented by public keys), by a set of key blocks each of which wrapping that key under different target keys. </p>
<p>If the key to be distributed is a private key, it is first wrapped under a nonce key, and that nonce key is stored encrypted under the keys of the receiving entitites.</p>
<p>Essentially a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html" title="A key directory holds a key (secret or private), distributed to entities (represented...">KeyDirectory</a> is a software wrapper for managing a set of content stored in CCNx (writing and reading portions of that content); that content consists of a set of key blocks used to give one key to a number of target entities.</p>
<p>Key blocks are implemented as a set of wrapped key objects all stored in one directory. Wrapped key objects are typically short and only need one segment. The directory the keys are stored in is prefixed by a version, to allow the contents to evolve. In addition some potential supporting information pointing to previous or subsequent versions of this key is kept. A particular wrapped key entry's name would look like:</p>
<pre>&lt;keyname&gt;/version/xxx/s0</pre><p> <br/>
Where xxx is the identifier of the wrapped key.</p>
<p>This structure is used for representing both node keys and group (private) keys. We encapsulate functionality to walk such a directory and find our target key here.</p>
<p>We also store links providing additional information about how to retrieve this key -- e.g. a link from a given group or principal name to a key ID-named block, in case a group member does not know an earlier version of their group public key. Or links to keys this key supercedes or precedes.</p>
<p>Our model is that higher-level function may use this interface to try many ways to get a given key. Some will work (access is allowed), some may not -- the latter does not mean that the principal doesn't have access, just that the principal doesn't have access by this route. So for the moment, we return null when we don't conclusively know that this principal doesn't have access to this data somehow, rather than throwing <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1_access_denied_exception.html" title="A real AccessDeniedException doesn&#39;t appear in Java until 1.7.">AccessDeniedException</a>. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a62bcf87a2cca5a19e609fb8399032857"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::KeyDirectory" ref="a62bcf87a2cca5a19e609fb8399032857" args="(GroupAccessControlManager manager, ContentName directoryName, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.profiles.security.access.group.KeyDirectory.KeyDirectory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_group_access_control_manager.html">GroupAccessControlManager</a>&nbsp;</td>
          <td class="paramname"> <em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>directoryName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Directory name should be versioned, else we pull the latest version; start enumeration. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>manager</em>&nbsp;</td><td>the access control manager. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>directoryName</em>&nbsp;</td><td>the root of the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html" title="A key directory holds a key (secret or private), distributed to entities (represented...">KeyDirectory</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac25d70b20cd73eb09114e80325437df3"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::KeyDirectory" ref="ac25d70b20cd73eb09114e80325437df3" args="(GroupAccessControlManager manager, ContentName directoryName, boolean enumerate, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.profiles.security.access.group.KeyDirectory.KeyDirectory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_group_access_control_manager.html">GroupAccessControlManager</a>&nbsp;</td>
          <td class="paramname"> <em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>directoryName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>enumerate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Directory name should be versioned, else we pull the latest version. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>manager</em>&nbsp;</td><td>the access control manager. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>directoryName</em>&nbsp;</td><td>the root of the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html" title="A key directory holds a key (secret or private), distributed to entities (represented...">KeyDirectory</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9e6f2e6e868fab4fca48878e4f1a1d63"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::addPreviousKeyBlock" ref="a9e6f2e6e868fab4fca48878e4f1a1d63" args="(Key oldPrivateKeyWrappingKey, ContentName supersedingKeyName, Key newPrivateKeyWrappingKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.profiles.security.access.group.KeyDirectory.addPreviousKeyBlock </td>
          <td>(</td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>oldPrivateKeyWrappingKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>supersedingKeyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>newPrivateKeyWrappingKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a previous key block to the repository. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>oldPrivateKeyWrappingKey</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>supersedingKeyName</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newPrivateKeyWrappingKey</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentEncodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a769dda93f706af17dcf1e170eeb62fc5"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::addPreviousKeyLink" ref="a769dda93f706af17dcf1e170eeb62fc5" args="(ContentName previousKey, PublisherID previousKeyPublisher)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.profiles.security.access.group.KeyDirectory.addPreviousKeyLink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>previousKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_i_d.html">PublisherID</a>&nbsp;</td>
          <td class="paramname"> <em>previousKeyPublisher</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a link to a previous key to the repository. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>previousKey</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>previousKeyPublisher</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentEncodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8053387680e34fbbb9f61f962e98ad1c"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::addPrincipal" ref="a8053387680e34fbbb9f61f962e98ad1c" args="(byte[] wkChildName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.profiles.security.access.group.KeyDirectory.addPrincipal </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>wkChildName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a principal name. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wkChildName</em>&nbsp;</td><td>the principal name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a582e7c208735ce467f0640782f3335a5"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::addPrivateKeyBlock" ref="a582e7c208735ce467f0640782f3335a5" args="(PrivateKey privateKey, Key privateKeyWrappingKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.profiles.security.access.group.KeyDirectory.addPrivateKeyBlock </td>
          <td>(</td>
          <td class="paramtype">PrivateKey&nbsp;</td>
          <td class="paramname"> <em>privateKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>privateKeyWrappingKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a>, IOException, InvalidKeyException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a private key block to the repository. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>privateKey</em>&nbsp;</td><td>the private key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>privateKeyWrappingKey</em>&nbsp;</td><td>the wrapping key used to wrap the private key. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentEncodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9c7cc6520e2d970d6746c9ed8a7a603"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::addSupersededByBlock" ref="ac9c7cc6520e2d970d6746c9ed8a7a603" args="(ContentName oldKeyVersionedNameToAddBlockTo, Key oldKeyToBeSuperseded, ContentName storedSupersedingKeyName, byte[] storedSupersedingKeyID, Key supersedingKey, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void org.ccnx.ccn.profiles.security.access.group.KeyDirectory.addSupersededByBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>oldKeyVersionedNameToAddBlockTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>oldKeyToBeSuperseded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>storedSupersedingKeyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>storedSupersedingKeyID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>supersedingKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a>, IOException, InvalidKeyException <code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a superseded-by block to another node key, where we may have only its name, not its enumeration. </p>
<p>Use as a static method to add our own superseded-by blocks as well. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentEncodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9a8ad0d5e599fcfae281179430d6ff5"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::addSupersededByBlock" ref="aa9a8ad0d5e599fcfae281179430d6ff5" args="(Key oldPrivateKeyWrappingKey, ContentName storedSupersedingKeyName, byte[] storedSupersedingKeyID, Key newPrivateKeyWrappingKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.profiles.security.access.group.KeyDirectory.addSupersededByBlock </td>
          <td>(</td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>oldPrivateKeyWrappingKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>storedSupersedingKeyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>storedSupersedingKeyID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>newPrivateKeyWrappingKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a superseded-by block to our key directory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>oldPrivateKeyWrappingKey</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>supersedingKeyName</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newPrivateKeyWrappingKey</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentEncodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30c9b06a64136a0d99db4a41dfb20615"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::addWrappedKeyBlock" ref="a30c9b06a64136a0d99db4a41dfb20615" args="(Key secretKeyToWrap, ContentName publicKeyName, PublicKey publicKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.profiles.security.access.group.KeyDirectory.addWrappedKeyBlock </td>
          <td>(</td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>secretKeyToWrap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>publicKeyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PublicKey&nbsp;</td>
          <td class="paramname"> <em>publicKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a>, IOException, InvalidKeyException, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_version_missing_exception.html">VersionMissingException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a wrapped key block to the repository. </p>
<p>Eventually aggregate signing and repo stream operations at the very least across writing paired objects and links, preferably across larger swaths of data. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>secretKeyToWrap</em>&nbsp;</td><td>either a node key, a data key, or a private key wrapping key </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publicKeyName</em>&nbsp;</td><td>the name of the public key. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publicKey</em>&nbsp;</td><td>the public key. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentEncodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_version_missing_exception.html" title="Thrown when a version field is expected and can&#39;t be found.">VersionMissingException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_version_missing_exception.html" title="Thrown when a version field is expected and can&#39;t be found.">VersionMissingException</a></em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6e296be639397cef237e28cbda2d3a8"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getCopyOfOtherNames" ref="ae6e296be639397cef237e28cbda2d3a8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TreeSet&lt;byte []&gt; org.ccnx.ccn.profiles.security.access.group.KeyDirectory.getCopyOfOtherNames </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a copy to avoid synchronization problems. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentNotReadyException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56f067275c0eb608ff620427459c3109"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getCopyOfPrincipals" ref="a56f067275c0eb608ff620427459c3109" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HashMap&lt;String, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_group_access_control_profile_1_1_principal_info.html">PrincipalInfo</a>&gt; org.ccnx.ccn.profiles.security.access.group.KeyDirectory.getCopyOfPrincipals </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a copy to avoid synchronization problems. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentNotReadyException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41b9807389292ac353f487730cbee700"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getCopyOfWrappingKeyIDs" ref="a41b9807389292ac353f487730cbee700" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TreeSet&lt;byte []&gt; org.ccnx.ccn.profiles.security.access.group.KeyDirectory.getCopyOfWrappingKeyIDs </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a copy to avoid synchronization problems. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentNotReadyException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeec7ea373078dd92176ade55f0712beb"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getPreviousKey" ref="aeec7ea373078dd92176ade55f0712beb" args="(long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_link.html">Link</a> org.ccnx.ccn.profiles.security.access.group.KeyDirectory.getPreviousKey </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a link to the previous key. </p>
<p>Previous key might be a link, if we're a simple newer version, or it might be a wrapped key, if we're an interposed node key. DKS TODO </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentNotReadyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90be6c833df9a0e7a1dcf5057490c4e5"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getPrincipalInfo" ref="a90be6c833df9a0e7a1dcf5057490c4e5" args="(String principal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_group_access_control_profile_1_1_principal_info.html">PrincipalInfo</a> org.ccnx.ccn.profiles.security.access.group.KeyDirectory.getPrincipalInfo </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>principal</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns principal info. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentNotReadyException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a555e24fe63aaf6175e2f2cc88da82c7a"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getPrivateKey" ref="a555e24fe63aaf6175e2f2cc88da82c7a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PrivateKey org.ccnx.ccn.profiles.security.access.group.KeyDirectory.getPrivateKey </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1_access_denied_exception.html">AccessDeniedException</a>, InvalidKeyException,  	<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a>, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_gone_exception.html">ContentGoneException</a>, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a>,  	IOException, NoSuchAlgorithmException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the private key stored in the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html" title="A key directory holds a key (secret or private), distributed to entities (represented...">KeyDirectory</a>. </p>
<p>The private key is wrapped in a wrapping key, which is itself wrapped. So the unwrapping proceeds in two steps. First, we unwrap the wrapping key for the private key. Then, we unwrap the private key itself. Relies on the caller, who presumably knows the public key, to add the result to the cache. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1_access_denied_exception.html" title="A real AccessDeniedException doesn&#39;t appear in Java until 1.7.">AccessDeniedException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentGoneException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentNotReadyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2934b8470f59c87a26dd689aa8a8076c"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getPrivateKeyObject" ref="a2934b8470f59c87a26dd689aa8a8076c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a> org.ccnx.ccn.profiles.security.access.group.KeyDirectory.getPrivateKeyObject </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_gone_exception.html">ContentGoneException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the private key object, if one exists as a wrapped key object. </p>
<p>Does not check to see if we have a private key block; simply sends a request for it (saves the requirement to do enumeration). Callers should check available() on the result to see if we actually got one. In general, callers will know whether one should exist or not. hasPrivateKeyBlock can be used to <a class="el" href="namespaceorg_1_1ccnx_1_1ccn_1_1test.html" title="PD org.ccnx.ccn.test.">test</a> (after enumeration) whether one exists if you don't know. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentGoneException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae40b202bb881fc1e96aad52f87e6acef"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getSupersededWrappedKey" ref="ae40b202bb881fc1e96aad52f87e6acef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a> org.ccnx.ccn.profiles.security.access.group.KeyDirectory.getSupersededWrappedKey </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a>, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>We have several choices for how to represent superseded and previous keys. </p>
<p>Ignoring for now the case where we might have to have more than one per key directory (e.g. if we represent removal of several interposed ACLs), we could have the wrapped key block stored in the superseded block location, and the previous key block be a link, or the previous key block be a wrapped key and the superseded location be a link. Or we could store wrapped key blocks in both places. Because the wrapped key blocks can contain the name of the key that wrapped them (but not the key being wrapped), they are in essence a pointer forward to the replacing key. So, the superseded block, if it contains a wrapped key, is both a key and a link. If the block was stored at the previous key, it would not be both a key and a link, as its wrapping key is indicated by where it is. So it should indeed be a link -- except in the case of an interposed <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_a_c_l.html" title="This class represents an Access Control List (ACLs) for CCN content, for use with...">ACL</a>, where there is nothing to link to; and it instead stores a wrapped key block containing the effective node key that was the previous key. This method checks for the existence of a superseded block. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentNotReadyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d9472fe632ce3ebf99f5eefbde49b67"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getUnwrappedKey" ref="a5d9472fe632ce3ebf99f5eefbde49b67" args="(byte[] expectedKeyID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key org.ccnx.ccn.profiles.security.access.group.KeyDirectory.getUnwrappedKey </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>expectedKeyID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws InvalidKeyException, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a>, IOException, NoSuchAlgorithmException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unwrap and return the key wrapped in a wrapping key specified by its digest. </p>
<p>Find a copy of the key block in this directory that we can unwrap (either the private key wrapping key block or a wrapped raw symmetric key). Chase superseding keys if we have to. This mechanism should be generic, and should work for node keys as well as private key wrapping keys in directories following this structure. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3dc55a428ed2df0f27ac20087e92c23"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getWrappedKey" ref="af3dc55a428ed2df0f27ac20087e92c23" args="(ContentName wrappedKeyName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a> org.ccnx.ccn.profiles.security.access.group.KeyDirectory.getWrappedKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>wrappedKeyName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the wrapped key object corresponding to the specified wrapped key name. </p>
<p>We know there is only one version of this object, so avoid getLatestVersion. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wrappedKeyName</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abca4d663fe4c557dbdedcf9f538414c2"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getWrappedKeyForKeyID" ref="abca4d663fe4c557dbdedcf9f538414c2" args="(byte[] keyID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a> org.ccnx.ccn.profiles.security.access.group.KeyDirectory.getWrappedKeyForKeyID </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>keyID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the wrapped key object corresponding to a public key specified by its digest. </p>
<p>Up to caller to decide when this is reasonable to call; should call available() on result. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyID</em>&nbsp;</td><td>the digest of the specified public key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the corresponding wrapped key object. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afe54f9c58f223652911f7ac5f2bd37e0"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getWrappedKeyForPrincipal" ref="afe54f9c58f223652911f7ac5f2bd37e0" args="(String principalName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_wrapped_key_1_1_wrapped_key_object.html">WrappedKeyObject</a> org.ccnx.ccn.profiles.security.access.group.KeyDirectory.getWrappedKeyForPrincipal </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>principalName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a>, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the wrapped key object corresponding to a specified principal. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>principalName</em>&nbsp;</td><td>the principal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the corresponding wrapped key object. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentNotReadyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0795d18502c234dd973f33c1dbef4efe"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getWrappedKeyNameForKeyID" ref="a0795d18502c234dd973f33c1dbef4efe" args="(byte[] keyID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.profiles.security.access.group.KeyDirectory.getWrappedKeyNameForKeyID </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>keyID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the wrapped key name for a public key specified by its digest. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyID</em>&nbsp;</td><td>the digest of the public key. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the corresponding wrapped key name. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8a430f9675cead22131f0e5a69c8e56"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getWrappedKeyNameForPrincipal" ref="ad8a430f9675cead22131f0e5a69c8e56" args="(ContentName principalPublicKeyName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.profiles.security.access.group.KeyDirectory.getWrappedKeyNameForPrincipal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>principalPublicKeyName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_version_missing_exception.html">VersionMissingException</a>, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the wrapped key name for a principal specified by the name of its public key. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>principalPublicKeyName</em>&nbsp;</td><td>the name of the public key of the principal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the corresponding wrapped key name. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_version_missing_exception.html" title="Thrown when a version field is expected and can&#39;t be found.">VersionMissingException</a></em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentEncodingException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0aa9ef728931bee3ea7569bd1407e504"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::getWrappedKeyNameForPrincipal" ref="a0aa9ef728931bee3ea7569bd1407e504" args="(PrincipalInfo pi)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.profiles.security.access.group.KeyDirectory.getWrappedKeyNameForPrincipal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_group_access_control_profile_1_1_principal_info.html">PrincipalInfo</a>&nbsp;</td>
          <td class="paramname"> <em>pi</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the wrapped key name for a specified principal. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>isGroup</em>&nbsp;</td><td>whether the principal is a group. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>principalName</em>&nbsp;</td><td>the name of the principal. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>principalVersion</em>&nbsp;</td><td>the version of the principal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the corresponding wrapped key name. </dd></dl>

</div>
</div>
<a class="anchor" id="a1625b43b02ba5fec51ded074ec5ce52d"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::hasPreviousKeyBlock" ref="a1625b43b02ba5fec51ded074ec5ce52d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.profiles.security.access.group.KeyDirectory.hasPreviousKeyBlock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for the existence of a previous key block. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentNotReadyException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4239f4704d5229d55e2cda0440060c6d"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::hasPrivateKeyBlock" ref="a4239f4704d5229d55e2cda0440060c6d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.profiles.security.access.group.KeyDirectory.hasPrivateKeyBlock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>We store a private key as a single block wrapped under a nonce key, which is then wrapped under the public keys of various principals. </p>
<p>The WrappedKey structure would allow us to do this (wrap private in public) in a single object, with an inline nonce key, but this option is more efficient. Checks for the existence of a private key block </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentNotReadyException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4b33408f39ce07f6a514e8ddd6ba9e6"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::hasResult" ref="aa4b33408f39ce07f6a514e8ddd6ba9e6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.profiles.security.access.group.KeyDirectory.hasResult </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subclasses should override this <a class="el" href="namespaceorg_1_1ccnx_1_1ccn_1_1test.html" title="PD org.ccnx.ccn.test.">test</a> to answer true if waiters should break out of a waitForNoUpdatesOrResult loop. </p>
<p>Note that results must be cleared manually using clearResult. Default behavior always returns false. Subclasses probably want to set a variable in processNewChildren that will be read here. </p>

<p>Reimplemented from <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1nameenum_1_1_enumerated_name_list.html#af593f0d16a23fc8b8488487e6fce7c81">org.ccnx.ccn.profiles.nameenum.EnumeratedNameList</a>.</p>

</div>
</div>
<a class="anchor" id="ae5785016391032e8ef33c67b5bc9a848"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::hasSupersededBlock" ref="ae5785016391032e8ef33c67b5bc9a848" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.profiles.security.access.group.KeyDirectory.hasSupersededBlock </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks for the existence of a superseded block. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentNotReadyException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae0ea55e6f0b181ebec43daeb00700255"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::initialize" ref="ae0ea55e6f0b181ebec43daeb00700255" args="(boolean startEnumerating)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.profiles.security.access.group.KeyDirectory.initialize </td>
          <td>(</td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>startEnumerating</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>We don't start enumerating until we get here. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae1a2d952abf2404ee45245ffafb7ee2d"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::isPrivateKeyInCache" ref="ae1a2d952abf2404ee45245ffafb7ee2d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.profiles.security.access.group.KeyDirectory.isPrivateKeyInCache </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the private key is in the secure key cache. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b4fc6ef3279410d712daa81011e9343"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::isUnwrappedKeyInCache" ref="a7b4fc6ef3279410d712daa81011e9343" args="(byte[] expectedKeyID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.profiles.security.access.group.KeyDirectory.isUnwrappedKeyInCache </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>expectedKeyID</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>expectedKeyID</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the unwrapped key specified by expectedKeyID (if not null) or by the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1security_1_1access_1_1group_1_1_key_directory.html" title="A key directory holds a key (secret or private), distributed to entities (represented...">KeyDirectory</a> name, is in the secure key cache. </dd></dl>

</div>
</div>
<a class="anchor" id="a1fdd71f8730b82e0e728883216e4666c"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::unwrapKeyForPrincipal" ref="a1fdd71f8730b82e0e728883216e4666c" args="(String principal, Key unwrappingKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key org.ccnx.ccn.profiles.security.access.group.KeyDirectory.unwrapKeyForPrincipal </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>principal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Key&nbsp;</td>
          <td class="paramname"> <em>unwrappingKey</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a>,  	<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a>, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_gone_exception.html">ContentGoneException</a>, IOException, NoSuchAlgorithmException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unwrap the key wrapped under a specified principal, with a specified unwrapping key. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>principal</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>unwrappingKey</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentGoneException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentNotReadyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf95e58412b70fb5a92c76f086da2738"></a><!-- doxytag: member="org::ccnx::ccn::profiles::security::access::group::KeyDirectory::unwrapKeyViaCache" ref="adf95e58412b70fb5a92c76f086da2738" args="(byte[] keyIDOfCachedKeytoUse)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Key org.ccnx.ccn.profiles.security.access.group.KeyDirectory.unwrapKeyViaCache </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>keyIDOfCachedKeytoUse</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a>, IOException, InvalidKeyException, NoSuchAlgorithmException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fast path -- once we have an idea which of our keys will unwrap this key, get it. </p>
<p>Can be called after enumeration, or if we have a guess of what key to use. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keyIDOfCachedKeytoUse</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/org/ccnx/ccn/profiles/security/access/group/KeyDirectory.java</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Thu Nov 4 13:34:29 2010 for Content-Centric Networking in Java by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
