<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Content-Centric Networking in Java: org.ccnx.ccn.impl.security.crypto.MerkleTree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>org</b>.<b>ccnx</b>.<b>ccn</b>.<b>impl</b>.<b>security</b>.<b>crypto</b>.<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html">MerkleTree</a>
  </div>
</div>
<div class="contents">
<h1>org.ccnx.ccn.impl.security.crypto.MerkleTree Class Reference</h1><!-- doxytag: class="org::ccnx::ccn::impl::security::crypto::MerkleTree" -->
<p>Implementation of a Merkle hash tree.  
<a href="#_details">More...</a></p>

<p><a href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a45b53e73bfd5013b78cd12fc8348e2ad">MerkleTree</a> (String digestAlgorithm, byte contentBlocks[][], boolean isDigest, int blockCount, int baseBlockIndex, int lastBlockLength)  throws NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html" title="Implementation of a Merkle hash tree.">MerkleTree</a>.  <a href="#a45b53e73bfd5013b78cd12fc8348e2ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a753bab134184d2eefc423f405e0636f4">MerkleTree</a> (byte[] content, int offset, int length, int blockWidth)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Segment content and build a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html" title="Implementation of a Merkle hash tree.">MerkleTree</a>.  <a href="#a753bab134184d2eefc423f405e0636f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#adc8ae44352ede47f6e00452487dcceee">MerkleTree</a> (String digestAlgorithm, byte[] content, int offset, int length, int blockWidth)  throws NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Segment content and build a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html" title="Implementation of a Merkle hash tree.">MerkleTree</a>.  <a href="#adc8ae44352ede47f6e00452487dcceee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a2cba1b16839652eda0bd27f305539f1d">MerkleTree</a> (byte contentBlocks[][], boolean isDigest, int blockCount, int baseBlockIndex, int lastBlockLength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html" title="Implementation of a Merkle hash tree.">MerkleTree</a>.  <a href="#a2cba1b16839652eda0bd27f305539f1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a2526f564f0279f5042f10c5c1169839c">digestAlgorithm</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the digest algorithm used by this tree.  <a href="#a2526f564f0279f5042f10c5c1169839c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a2068e224e849d3385dbe05eb9d4ae769">leftChild</a> (int nodeIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the index of the left child of a given node.  <a href="#a2068e224e849d3385dbe05eb9d4ae769"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a7b10a21605afec5c73f0b9aa79dc131b">rightChild</a> (int nodeIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the index of the right child of a given node.  <a href="#a7b10a21605afec5c73f0b9aa79dc131b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#adc1c3a2a29093e7036ff9fdff3ea3ad7">root</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the root digest.  <a href="#adc1c3a2a29093e7036ff9fdff3ea3ad7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DEROctetString&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a614321979b46b4fcb5b7b429cd759d58">derRoot</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the DEROctetString wrapped digest of the root node.  <a href="#a614321979b46b4fcb5b7b429cd759d58"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#ac9a3e1148f61edcbe0e2aab2136017bb">size</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the size of the tree, in nodes.  <a href="#ac9a3e1148f61edcbe0e2aab2136017bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#ae24ac63bf6acecf1cd1caaee07c23084">get</a> (int nodeIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the digest at the specified node.  <a href="#ae24ac63bf6acecf1cd1caaee07c23084"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">DEROctetString&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a9e64ecac9876ebfaac607d1654223e4a">derGet</a> (int nodeIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the digest at the specified node as a DEROctetString.  <a href="#a9e64ecac9876ebfaac607d1654223e4a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#acf1874ddd7399eae4bfdf7d61042a278">numLeaves</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of leaves in the tree.  <a href="#acf1874ddd7399eae4bfdf7d61042a278"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#acf85950f5d163b7957e9a620aa7c0d7d">nodeCount</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the number of nodes in this tree.  <a href="#acf85950f5d163b7957e9a620aa7c0d7d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#abae3dec233c457c115f49900f8cffa60">firstLeaf</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the node index of the first leaf.  <a href="#abae3dec233c457c115f49900f8cffa60"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#ade64e648b68cfaff229bdd2543a6103c">leafNodeIndex</a> (int leafIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the node index of a given leaf.  <a href="#ade64e648b68cfaff229bdd2543a6103c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a153da4d0792f8b79b9b5d5fc739c0e21">leaf</a> (int leafIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the digest of a given leaf node.  <a href="#a153da4d0792f8b79b9b5d5fc739c0e21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_path.html">MerklePath</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#ad6e2ad75a3276115e28f758257b0c979">path</a> (int leafNum)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generate a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_path.html" title="A representation of a path through a MerkleTree.">MerklePath</a> for a given leaf, to use in verifying that leaf.  <a href="#ad6e2ad75a3276115e28f758257b0c979"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a612b5228eb39c6935cc23413804d6a75">maxDepth</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the maximum depth of this <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html" title="Implementation of a Merkle hash tree.">MerkleTree</a>.  <a href="#a612b5228eb39c6935cc23413804d6a75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a50d620a0cbc575c7eef39b9f1d10990d">getNodeIndex</a> (DEROctetString node)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Function for validating paths.  <a href="#a50d620a0cbc575c7eef39b9f1d10990d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a43cf2a676824c7599e4dc94cac95ada4">getRootAsEncodedDigest</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the root node as an encoded PKCS#1 DigestInfo.  <a href="#a43cf2a676824c7599e4dc94cac95ada4"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#acbf9cff7981fa74b3197fb1541630384">parent</a> (int nodeIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the index of the parent of this node.  <a href="#acbf9cff7981fa74b3197fb1541630384"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a05c89eb35fd3dbfddb3c50c1761d5160">sibling</a> (int nodeIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the index of this node's sibling.  <a href="#a05c89eb35fd3dbfddb3c50c1761d5160"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a520de748f42ac7a5c8e996702c27ac41">isRight</a> (int nodeIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check internal node index (not translated to leaves) to see if it is a left or right child.  <a href="#a520de748f42ac7a5c8e996702c27ac41"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a633e26ba353b4d02ac89d64631258bda">isLeft</a> (int nodeIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check internal node index (not translated to leaves) to see if it is a left or right child.  <a href="#a633e26ba353b4d02ac89d64631258bda"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#ac423384c1216c3d54de7feb7dcb0b5fe">nodeCount</a> (int numLeaves)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the number of nodes in a tree with a given number of leaves.  <a href="#ac423384c1216c3d54de7feb7dcb0b5fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a48314bda32e60d25cb68e175d2b084eb">maxPathLength</a> (int nodeIndex)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">What is the maximum path length to a node with this node index, including its sibling but not including the root?  <a href="#a48314bda32e60d25cb68e175d2b084eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a91cace4bd02959445ade0ad8708e9267">maxDepth</a> (int numLeaves)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">What is the maximum depth of a Merkle tree with a given number of leaves.  <a href="#a91cace4bd02959445ade0ad8708e9267"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#af227b222157a0a01cbbc5f8ed6475c07">computeBlockDigest</a> (String digestAlgorithm, byte[] content)  throws NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the digest of a leaf node.  <a href="#af227b222157a0a01cbbc5f8ed6475c07"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#aa694e98f9cb11ee0a010514fca410aeb">computeBlockDigest</a> (String digestAlgorithm, byte[] content, int offset, int length)  throws NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the digest of a leaf node.  <a href="#aa694e98f9cb11ee0a010514fca410aeb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a832c5ab97979f45d0340a2771d21dc84">computeBlockDigest</a> (byte[] block)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the digest of a block using <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_c_c_n_digest_helper.html#a4816cea79b02a8c027fd176aa0c73a57" title="Current default algorithm is SHA-256.">CCNDigestHelper.DEFAULT_DIGEST_ALGORITHM</a>.  <a href="#a832c5ab97979f45d0340a2771d21dc84"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a209951a0637f6cfa8d535484074730cb">computeNodeDigest</a> (String algorithm, byte[] left, byte[] right)  throws NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the digest for an intermediate node.  <a href="#a209951a0637f6cfa8d535484074730cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#ac59a337a6272d31f111fe081af29b3ef">computeNodeDigest</a> (byte[] left, byte[] right)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the digest for an intermediate node with two children.  <a href="#ac59a337a6272d31f111fe081af29b3ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#ae769b5ef41e2aa4ac2e29e449e3aff2f">isMerkleTree</a> (AlgorithmIdentifier algorithmId)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Does this algorithm identifier indicate a Merkle tree?  <a href="#ae769b5ef41e2aa4ac2e29e449e3aff2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a76d858eb6274917f09b7ccfcab23d657">log2</a> (int arg)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper method.  <a href="#a76d858eb6274917f09b7ccfcab23d657"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#aa42283b03d6c01e8299f363946b08c0f">blockCount</a> (int length, int blockWidth)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of blocks of blockWidth length in a buffer of length bytes.  <a href="#aa42283b03d6c01e8299f363946b08c0f"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a89c86cff82adcd0dca5bd6c3de61f542">MerkleTree</a> (String digestAlgorithm, int numLeaves)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Subclass constructor.  <a href="#a89c86cff82adcd0dca5bd6c3de61f542"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a92bd24c35e26dd0220ae43328908519b">initializeTree</a> (byte contentBlocks[][], boolean isDigest, int baseBlockIndex, int lastBlockLength)  throws NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method called by constructors to fill leaf nodes with digests and compute intermediate node values up the tree.  <a href="#a92bd24c35e26dd0220ae43328908519b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a6d235d7014796f05d0ad82a6d7c1f5ea">initializeTree</a> (byte[] content, int offset, int length, int blockWidth)  throws NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method called by constructors to fill leaf nodes with digests and compute intermediate node values up the tree.  <a href="#a6d235d7014796f05d0ad82a6d7c1f5ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a1083f7720753fa7ae8cd6e12d5425c5b">computeLeafValues</a> (byte contentBlocks[][], boolean isDigest, int baseBlockIndex, int lastBlockLength)  throws NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the raw digest of the leaf content blocks, and format them appropriately.  <a href="#a1083f7720753fa7ae8cd6e12d5425c5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a7452e0a1c48437faefe054c70615b7e8">computeLeafValues</a> (byte[] content, int offset, int length, int blockWidth)  throws NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the raw digest of the leaf content blocks, and format them appropriately.  <a href="#a7452e0a1c48437faefe054c70615b7e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a220c6b4992d6d718a736c4c594ef280f">computeNodeValues</a> ()  throws NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the intermediate node values by digesting the concatenation of the left and right children (or the left child alone if there is no right child).  <a href="#a220c6b4992d6d718a736c4c594ef280f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a1614c651e4916d31d957894f3ce62c38">computeBlockDigest</a> (int leafIndex, byte contentBlocks[][], int baseBlockIndex, int lastBlockLength)  throws NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the digest of a leaf node.  <a href="#a1614c651e4916d31d957894f3ce62c38"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a2dc111a42dbfe99fce825d0221a7b4b8">computeBlockDigest</a> (int leafIndex, byte[] content, int offset, int length)  throws NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the digest of a leaf node.  <a href="#a2dc111a42dbfe99fce825d0221a7b4b8"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac2dd74e4e06715402ce1db487aea5f83"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::_tree" ref="ac2dd74e4e06715402ce1db487aea5f83" args="" -->
DEROctetString[]&nbsp;</td><td class="memItemRight" valign="bottom"><b>_tree</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adbcce8b0e6a5b3e3d07053db29594024"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::_numLeaves" ref="adbcce8b0e6a5b3e3d07053db29594024" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>_numLeaves</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae336e334edc39866782eb6000f80d544"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::_digestAlgorithm" ref="ae336e334edc39866782eb6000f80d544" args="" -->
String&nbsp;</td><td class="memItemRight" valign="bottom"><b>_digestAlgorithm</b></td></tr>
<tr><td colspan="2"><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed2dd07d41c470d582aa33a28e008205"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::ROOT_NODE" ref="aed2dd07d41c470d582aa33a28e008205" args="" -->
static final int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#aed2dd07d41c470d582aa33a28e008205">ROOT_NODE</a> = 1</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Node index of 1 (array index of 0). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static final String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#ae230a60612dfc034d395425428be13fb">MERKLE_OID_PREFIX</a> = &quot;1.2.840.113550.11.1.2&quot;</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The OID prefix we use to represent Merkle trees.  <a href="#ae230a60612dfc034d395425428be13fb"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Implementation of a Merkle hash tree. </p>
<p>Representation based on Knuth, Vol 1, section 2.3.4.5. We represent trees as a special sublcass of extended binary trees, where empty subtrees are only present in one end of the tree.</p>
<p>Tree nodes are numbered starting with 1, which is the root.</p>
<p>Tree nodes are stored in an array, with node i stored at index i-1 into the array.</p>
<p>Incomplete binary trees are represented as multi-level extended binary trees -- lower-numbered leaves are represented in the upper half of the tree, in a layer one closer to the root than leaves in the complete subtree.</p>
<p>Total number of nodes in the tree = 2n + 1, where n is the number of leaves.</p>
<p>Taken in terms of node indices (where root == 1), the parent of node k is node floor(k/2), and the children of node k are nodes 2k and 2k+1. Leaves are numbered from node n+1 through 2n+1, where n is the number of leaves.</p>
<p>The sibling index of node k is (k xor 1).</p>
<p>Should we want to get fancy, we could have t-ary trees; the construction above works for tree with internal nodes (non-leaves) {1,2,...,n}.</p>
<p>The parent of node k is the node floor((k+t-2)/t) = ceil((k-1)/t). The children of node k are: t(k-1)+2, t(k-1)+3,..., tk+1</p>
<p>In the methods below, we refer to nodes as having a "nodeIndex" -- their 1-based index into the node array as described above. Leaf nodes also have a "leafIndex" -- their index into the set of n leaves. Convenience methods are provided to convert between the two.</p>
<p>Store node digests internally as DEROctetStrings for more efficient encoding. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a45b53e73bfd5013b78cd12fc8348e2ad"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::MerkleTree" ref="a45b53e73bfd5013b78cd12fc8348e2ad" args="(String digestAlgorithm, byte contentBlocks[][], boolean isDigest, int blockCount, int baseBlockIndex, int lastBlockLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.impl.security.crypto.MerkleTree.MerkleTree </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>digestAlgorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>contentBlocks</em>[][], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>isDigest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>baseBlockIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lastBlockLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws NoSuchAlgorithmException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html" title="Implementation of a Merkle hash tree.">MerkleTree</a>. </p>
<p>This initializes the tree with content, builds the leaf and intermediate digests, and derives the root digest. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>digestAlgorithm</em>&nbsp;</td><td>the digest algorithm to use for computing leaf and interior node digests of this tree </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contentBlocks</em>&nbsp;</td><td>the segmented leaf content to be hashed into this Merkle hash tree. One block per leaf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isDigest</em>&nbsp;</td><td>are the content blocks raw content (false), or are they already digested with digestAlgorithm? (default algorithm: <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_c_c_n_digest_helper.html#a4816cea79b02a8c027fd176aa0c73a57" title="Current default algorithm is SHA-256.">CCNDigestHelper.DEFAULT_DIGEST_ALGORITHM</a>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockCount</em>&nbsp;</td><td>the number of those blocks to include (e.g. we may not have filled our contentBlocks buffers prior to building the tree). Must be at least 2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseBlockIndex</em>&nbsp;</td><td>the offset into the contentBlocks array at which to start. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lastBlockLength</em>&nbsp;</td><td>the number of bytes of the last block to use </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a753bab134184d2eefc423f405e0636f4"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::MerkleTree" ref="a753bab134184d2eefc423f405e0636f4" args="(byte[] content, int offset, int length, int blockWidth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.impl.security.crypto.MerkleTree.MerkleTree </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockWidth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Segment content and build a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html" title="Implementation of a Merkle hash tree.">MerkleTree</a>. </p>
<p>This initializes the tree with content, builds the leaf and intermediate digests, and derives the root digest. Uses <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_c_c_n_digest_helper.html#a4816cea79b02a8c027fd176aa0c73a57" title="Current default algorithm is SHA-256.">CCNDigestHelper.DEFAULT_DIGEST_ALGORITHM</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>content</em>&nbsp;</td><td>the content to segment into leaves and hash into this Merkle hash tree. One blockWidth of content per leaf, except for the last leaf which may be shorter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>offset into content at which to start processing data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>number of bytes of content to process </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockWidth</em>&nbsp;</td><td>the length of leaf blocks to create </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc8ae44352ede47f6e00452487dcceee"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::MerkleTree" ref="adc8ae44352ede47f6e00452487dcceee" args="(String digestAlgorithm, byte[] content, int offset, int length, int blockWidth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.impl.security.crypto.MerkleTree.MerkleTree </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>digestAlgorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockWidth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws NoSuchAlgorithmException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Segment content and build a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html" title="Implementation of a Merkle hash tree.">MerkleTree</a>. </p>
<p>This initializes the tree with content, builds the leaf and intermediate digests, and derives the root digest. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>digestAlgorithm</em>&nbsp;</td><td>the digest algorithm to use for computing leaf and interior node digests of this tree </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>content</em>&nbsp;</td><td>the content to segment into leaves and hash into this Merkle hash tree. One blockWidth of content per leaf, except for the last leaf which may be shorter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>offset into content at which to start processing data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>number of bytes of content to process </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockWidth</em>&nbsp;</td><td>the length of leaf blocks to create </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2cba1b16839652eda0bd27f305539f1d"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::MerkleTree" ref="a2cba1b16839652eda0bd27f305539f1d" args="(byte contentBlocks[][], boolean isDigest, int blockCount, int baseBlockIndex, int lastBlockLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.impl.security.crypto.MerkleTree.MerkleTree </td>
          <td>(</td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>contentBlocks</em>[][], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>isDigest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>baseBlockIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lastBlockLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Build a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html" title="Implementation of a Merkle hash tree.">MerkleTree</a>. </p>
<p>This initializes the tree with content, builds the leaf and intermediate digests, and derives the root digest. Uses <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_c_c_n_digest_helper.html#a4816cea79b02a8c027fd176aa0c73a57" title="Current default algorithm is SHA-256.">CCNDigestHelper.DEFAULT_DIGEST_ALGORITHM</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>contentBlocks</em>&nbsp;</td><td>the segmented leaf content to be hashed into this Merkle hash tree. One block per leaf. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isDigest</em>&nbsp;</td><td>are the content blocks raw content (false), or are they already digested with digestAlgorithm? (default algorithm: <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_c_c_n_digest_helper.html#a4816cea79b02a8c027fd176aa0c73a57" title="Current default algorithm is SHA-256.">CCNDigestHelper.DEFAULT_DIGEST_ALGORITHM</a>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockCount</em>&nbsp;</td><td>the number of those blocks to include (e.g. we may not have filled our contentBlocks buffers prior to building the tree). Must be at least 2. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseBlockIndex</em>&nbsp;</td><td>the offset into the contentBlocks array at which to start. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lastBlockLength</em>&nbsp;</td><td>the amount of the last block to use </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a89c86cff82adcd0dca5bd6c3de61f542"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::MerkleTree" ref="a89c86cff82adcd0dca5bd6c3de61f542" args="(String digestAlgorithm, int numLeaves)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.impl.security.crypto.MerkleTree.MerkleTree </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>digestAlgorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numLeaves</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Subclass constructor. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>digestAlgorithm</em>&nbsp;</td><td>digest algorithm to use. If null, use <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_c_c_n_digest_helper.html#a4816cea79b02a8c027fd176aa0c73a57" title="Current default algorithm is SHA-256.">CCNDigestHelper.DEFAULT_DIGEST_ALGORITHM</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numLeaves</em>&nbsp;</td><td>the number of leaf nodes to reserve space for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa42283b03d6c01e8299f363946b08c0f"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::blockCount" ref="aa42283b03d6c01e8299f363946b08c0f" args="(int length, int blockWidth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int org.ccnx.ccn.impl.security.crypto.MerkleTree.blockCount </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockWidth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The number of blocks of blockWidth length in a buffer of length bytes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>the buffer length </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockWidth</em>&nbsp;</td><td>the segment with </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of blocks </dd></dl>

</div>
</div>
<a class="anchor" id="a832c5ab97979f45d0340a2771d21dc84"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::computeBlockDigest" ref="a832c5ab97979f45d0340a2771d21dc84" args="(byte[] block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static byte [] org.ccnx.ccn.impl.security.crypto.MerkleTree.computeBlockDigest </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>block</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the digest of a block using <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_c_c_n_digest_helper.html#a4816cea79b02a8c027fd176aa0c73a57" title="Current default algorithm is SHA-256.">CCNDigestHelper.DEFAULT_DIGEST_ALGORITHM</a>. </p>
<p>DKS TODO - check -- was being by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_path.html" title="A representation of a path through a MerkleTree.">MerklePath</a> to compute digest for root without properly recovering OID from encoded path. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>block to digest </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>block digest </dd></dl>

</div>
</div>
<a class="anchor" id="aa694e98f9cb11ee0a010514fca410aeb"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::computeBlockDigest" ref="aa694e98f9cb11ee0a010514fca410aeb" args="(String digestAlgorithm, byte[] content, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static byte [] org.ccnx.ccn.impl.security.crypto.MerkleTree.computeBlockDigest </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>digestAlgorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws NoSuchAlgorithmException <code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the digest of a leaf node. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>digestAlgorithm</em>&nbsp;</td><td>the digest algorithm to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>content</em>&nbsp;</td><td>the content to segment into leaves and hash into this Merkle hash tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>offset into content at which this leaf starts </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>number of bytes of content in this leaf </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the digest for this leaf </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td>if digestAlgorithm is unknown </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af227b222157a0a01cbbc5f8ed6475c07"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::computeBlockDigest" ref="af227b222157a0a01cbbc5f8ed6475c07" args="(String digestAlgorithm, byte[] content)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static byte [] org.ccnx.ccn.impl.security.crypto.MerkleTree.computeBlockDigest </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>digestAlgorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>content</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws NoSuchAlgorithmException <code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the digest of a leaf node. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>digestAlgorithm</em>&nbsp;</td><td>the digest algorithm to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>content</em>&nbsp;</td><td>the content of this leaf </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the digest for this leaf </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td>if digestAlgorithm is unknown </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2dc111a42dbfe99fce825d0221a7b4b8"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::computeBlockDigest" ref="a2dc111a42dbfe99fce825d0221a7b4b8" args="(int leafIndex, byte[] content, int offset, int length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte [] org.ccnx.ccn.impl.security.crypto.MerkleTree.computeBlockDigest </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>leafIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws NoSuchAlgorithmException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the digest of a leaf node. </p>
<p>Separate this out so that it can be overridden. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>leafIndex</em>&nbsp;</td><td>The index of the leaf we are computing the digest of. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>content</em>&nbsp;</td><td>the content to segment into leaves and hash into this Merkle hash tree. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>offset into content at which this leaf starts </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>number of bytes of content in this leaf </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the digest for this leaf </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td>if digestAlgorithm is unknown </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_c_c_n_merkle_tree.html#a476635d1bc7f1773f0402de2a476287b">org.ccnx.ccn.impl.security.crypto.CCNMerkleTree</a>.</p>

</div>
</div>
<a class="anchor" id="a1614c651e4916d31d957894f3ce62c38"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::computeBlockDigest" ref="a1614c651e4916d31d957894f3ce62c38" args="(int leafIndex, byte contentBlocks[][], int baseBlockIndex, int lastBlockLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte [] org.ccnx.ccn.impl.security.crypto.MerkleTree.computeBlockDigest </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>leafIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>contentBlocks</em>[][], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>baseBlockIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lastBlockLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws NoSuchAlgorithmException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the digest of a leaf node. </p>
<p>Separate this out so that it can be overridden. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>leafIndex</em>&nbsp;</td><td>The index of the leaf we are computing the digest of. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contentBlocks</em>&nbsp;</td><td>The array of content blocks containing the leaf content. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseBlockIndex</em>&nbsp;</td><td>The first content block in the array containing leaf content (if rolling buffers). <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#acf1874ddd7399eae4bfdf7d61042a278" title="Get the number of leaves in the tree.">numLeaves()</a> blocks contain leaf content, so the last block used is blockOffset+numLeaves(). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lastBlockLength</em>&nbsp;</td><td>the number of bytes of the last block to use, can be smaller than the number available </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the digest for this leaf </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7452e0a1c48437faefe054c70615b7e8"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::computeLeafValues" ref="a7452e0a1c48437faefe054c70615b7e8" args="(byte[] content, int offset, int length, int blockWidth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.impl.security.crypto.MerkleTree.computeLeafValues </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockWidth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws NoSuchAlgorithmException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the raw digest of the leaf content blocks, and format them appropriately. </p>
<p>uses computeBlockDigest(int, byte[], int, int) to compute the leaf digest. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>content</em>&nbsp;</td><td>the content to segment into leaves and hash into this Merkle hash tree. One blockWidth of content per leaf, except for the last leaf which may be shorter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>offset into content at which to start processing data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>number of bytes of content to process </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockWidth</em>&nbsp;</td><td>the length of leaf blocks to create </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td>if digestAlgorithm is unknown </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1083f7720753fa7ae8cd6e12d5425c5b"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::computeLeafValues" ref="a1083f7720753fa7ae8cd6e12d5425c5b" args="(byte contentBlocks[][], boolean isDigest, int baseBlockIndex, int lastBlockLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.impl.security.crypto.MerkleTree.computeLeafValues </td>
          <td>(</td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>contentBlocks</em>[][], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>isDigest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>baseBlockIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lastBlockLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws NoSuchAlgorithmException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the raw digest of the leaf content blocks, and format them appropriately. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>contentBlocks</em>&nbsp;</td><td>the leaf content, one leaf per array </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isDigest</em>&nbsp;</td><td>have these been digested already, or do we need to digest them using computeBlockDigest(int, byte [][], int, int)? </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseBlockIndex</em>&nbsp;</td><td>first block in the array to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lastBlockLength</em>&nbsp;</td><td>number of bytes of the last block to use; N/A if isDigest is true </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td>if digestAlgorithm is unknown </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac59a337a6272d31f111fe081af29b3ef"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::computeNodeDigest" ref="ac59a337a6272d31f111fe081af29b3ef" args="(byte[] left, byte[] right)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static byte [] org.ccnx.ccn.impl.security.crypto.MerkleTree.computeNodeDigest </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>right</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the digest for an intermediate node with two children. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>left</em>&nbsp;</td><td>left child </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>right</em>&nbsp;</td><td>right child </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>parent digest </dd></dl>

</div>
</div>
<a class="anchor" id="a209951a0637f6cfa8d535484074730cb"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::computeNodeDigest" ref="a209951a0637f6cfa8d535484074730cb" args="(String algorithm, byte[] left, byte[] right)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static byte [] org.ccnx.ccn.impl.security.crypto.MerkleTree.computeNodeDigest </td>
          <td>(</td>
          <td class="paramtype">String&nbsp;</td>
          <td class="paramname"> <em>algorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>right</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws NoSuchAlgorithmException <code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the digest for an intermediate node. </p>
<p>If this is a last left child (right is null), simply hash left alone. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a220c6b4992d6d718a736c4c594ef280f"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::computeNodeValues" ref="a220c6b4992d6d718a736c4c594ef280f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.impl.security.crypto.MerkleTree.computeNodeValues </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws NoSuchAlgorithmException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the intermediate node values by digesting the concatenation of the left and right children (or the left child alone if there is no right child). </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td>if digestAlgorithm is unknown </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e64ecac9876ebfaac607d1654223e4a"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::derGet" ref="a9e64ecac9876ebfaac607d1654223e4a" args="(int nodeIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DEROctetString org.ccnx.ccn.impl.security.crypto.MerkleTree.derGet </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nodeIndex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the digest at the specified node as a DEROctetString. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nodeIndex</em>&nbsp;</td><td>1-based node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the digest for this node </dd></dl>

</div>
</div>
<a class="anchor" id="a614321979b46b4fcb5b7b429cd759d58"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::derRoot" ref="a614321979b46b4fcb5b7b429cd759d58" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DEROctetString org.ccnx.ccn.impl.security.crypto.MerkleTree.derRoot </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the DEROctetString wrapped digest of the root node. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>a DEROctetString object containing the root node digest. </dd></dl>

</div>
</div>
<a class="anchor" id="a2526f564f0279f5042f10c5c1169839c"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::digestAlgorithm" ref="a2526f564f0279f5042f10c5c1169839c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String org.ccnx.ccn.impl.security.crypto.MerkleTree.digestAlgorithm </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the digest algorithm used by this tree. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the digest algorithm used </dd></dl>

</div>
</div>
<a class="anchor" id="abae3dec233c457c115f49900f8cffa60"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::firstLeaf" ref="abae3dec233c457c115f49900f8cffa60" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.impl.security.crypto.MerkleTree.firstLeaf </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the node index of the first leaf. </p>
<p>The node index of the first leaf is either <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#ac9a3e1148f61edcbe0e2aab2136017bb" title="Get the size of the tree, in nodes.">size()</a>-numleaves(), or nodeIndex = numLeaves. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the first leaf's node index </dd></dl>

</div>
</div>
<a class="anchor" id="ae24ac63bf6acecf1cd1caaee07c23084"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::get" ref="ae24ac63bf6acecf1cd1caaee07c23084" args="(int nodeIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte [] org.ccnx.ccn.impl.security.crypto.MerkleTree.get </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nodeIndex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the digest at the specified node. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nodeIndex</em>&nbsp;</td><td>1-based node index </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the digest for this node </dd></dl>

</div>
</div>
<a class="anchor" id="a50d620a0cbc575c7eef39b9f1d10990d"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::getNodeIndex" ref="a50d620a0cbc575c7eef39b9f1d10990d" args="(DEROctetString node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.impl.security.crypto.MerkleTree.getNodeIndex </td>
          <td>(</td>
          <td class="paramtype">DEROctetString&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function for validating paths. </p>
<p>Given a digest, it returns what node in the tree has that digest. If no node has that digest, returns 0. If argument is null, returns -1. Slow. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>node</em>&nbsp;</td><td>the node digest to validate </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the nodeIndex of the node with that digest </dd></dl>

</div>
</div>
<a class="anchor" id="a43cf2a676824c7599e4dc94cac95ada4"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::getRootAsEncodedDigest" ref="a43cf2a676824c7599e4dc94cac95ada4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte [] org.ccnx.ccn.impl.security.crypto.MerkleTree.getRootAsEncodedDigest </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the root node as an encoded PKCS#1 DigestInfo. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the encoded DigestInfo </dd></dl>

</div>
</div>
<a class="anchor" id="a6d235d7014796f05d0ad82a6d7c1f5ea"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::initializeTree" ref="a6d235d7014796f05d0ad82a6d7c1f5ea" args="(byte[] content, int offset, int length, int blockWidth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.impl.security.crypto.MerkleTree.initializeTree </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockWidth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws NoSuchAlgorithmException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Method called by constructors to fill leaf nodes with digests and compute intermediate node values up the tree. </p>
<p>Does its work by calling computeLeafValues(byte [], int, int, int) and <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a220c6b4992d6d718a736c4c594ef280f" title="Compute the intermediate node values by digesting the concatenation of the left and...">computeNodeValues()</a>. Separate this out to allow subclasses to initialize members before building tree. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td>if the digestAlgorithm specified for this tree is unknown </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92bd24c35e26dd0220ae43328908519b"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::initializeTree" ref="a92bd24c35e26dd0220ae43328908519b" args="(byte contentBlocks[][], boolean isDigest, int baseBlockIndex, int lastBlockLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.impl.security.crypto.MerkleTree.initializeTree </td>
          <td>(</td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>contentBlocks</em>[][], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>isDigest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>baseBlockIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lastBlockLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws NoSuchAlgorithmException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Method called by constructors to fill leaf nodes with digests and compute intermediate node values up the tree. </p>
<p>Does its work by calling computeLeafValues(byte [][], boolean, int, int) and <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#a220c6b4992d6d718a736c4c594ef280f" title="Compute the intermediate node values by digesting the concatenation of the left and...">computeNodeValues()</a>. Separate this out to allow subclasses to initialize members before building tree. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td>if the digestAlgorithm specified for this tree is unknown </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a633e26ba353b4d02ac89d64631258bda"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::isLeft" ref="a633e26ba353b4d02ac89d64631258bda" args="(int nodeIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static boolean org.ccnx.ccn.impl.security.crypto.MerkleTree.isLeft </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nodeIndex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check internal node index (not translated to leaves) to see if it is a left or right child. </p>
<p>Internal nodes for a layer always start with an even index, as 1 is the root and the only layer with one member. Every other layer has an even number of nodes (except for possibly a dangling child at the end). So, left nodes have even indices, and right nodes have odd ones. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nodeIndex</em>&nbsp;</td><td>node to check whether it is a left child </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if it is a left child, false if a right child </dd></dl>

</div>
</div>
<a class="anchor" id="ae769b5ef41e2aa4ac2e29e449e3aff2f"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::isMerkleTree" ref="ae769b5ef41e2aa4ac2e29e449e3aff2f" args="(AlgorithmIdentifier algorithmId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static boolean org.ccnx.ccn.impl.security.crypto.MerkleTree.isMerkleTree </td>
          <td>(</td>
          <td class="paramtype">AlgorithmIdentifier&nbsp;</td>
          <td class="paramname"> <em>algorithmId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Does this algorithm identifier indicate a Merkle tree? </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>algorithmId</em>&nbsp;</td><td>the algorithm identifier </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if its a merkle tree, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a520de748f42ac7a5c8e996702c27ac41"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::isRight" ref="a520de748f42ac7a5c8e996702c27ac41" args="(int nodeIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static boolean org.ccnx.ccn.impl.security.crypto.MerkleTree.isRight </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nodeIndex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check internal node index (not translated to leaves) to see if it is a left or right child. </p>
<p>Internal nodes for a layer always start with an even index, as 1 is the root and the only layer with one member. Every other layer has an even number of nodes (except for possibly a dangling child at the end). So, left nodes have even indices, and right nodes have odd ones. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nodeIndex</em>&nbsp;</td><td>node to check whether it is a right child </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if it is a right child, false if a left child </dd></dl>

</div>
</div>
<a class="anchor" id="a153da4d0792f8b79b9b5d5fc739c0e21"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::leaf" ref="a153da4d0792f8b79b9b5d5fc739c0e21" args="(int leafIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte [] org.ccnx.ccn.impl.security.crypto.MerkleTree.leaf </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>leafIndex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the digest of a given leaf node. </p>
<p>Returns null if there is no leaf leafIndex. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>leafIndex</em>&nbsp;</td><td>leaf index, starting at 0 for the first leaf. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>its digest </dd></dl>

</div>
</div>
<a class="anchor" id="ade64e648b68cfaff229bdd2543a6103c"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::leafNodeIndex" ref="ade64e648b68cfaff229bdd2543a6103c" args="(int leafIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.impl.security.crypto.MerkleTree.leafNodeIndex </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>leafIndex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the node index of a given leaf. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>leafIndex</em>&nbsp;</td><td>the index of a leaf </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>its node index </dd></dl>

</div>
</div>
<a class="anchor" id="a2068e224e849d3385dbe05eb9d4ae769"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::leftChild" ref="a2068e224e849d3385dbe05eb9d4ae769" args="(int nodeIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.impl.security.crypto.MerkleTree.leftChild </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nodeIndex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the index of the left child of a given node. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nodeIndex</em>&nbsp;</td><td>the (1-based) index of the node whose child we want to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index of the left child, or <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#ac9a3e1148f61edcbe0e2aab2136017bb" title="Get the size of the tree, in nodes.">size()</a> if no left child. </dd></dl>

</div>
</div>
<a class="anchor" id="a76d858eb6274917f09b7ccfcab23d657"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::log2" ref="a76d858eb6274917f09b7ccfcab23d657" args="(int arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static double org.ccnx.ccn.impl.security.crypto.MerkleTree.log2 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>arg</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>arg</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>log base 2 of arg </dd></dl>

</div>
</div>
<a class="anchor" id="a612b5228eb39c6935cc23413804d6a75"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::maxDepth" ref="a612b5228eb39c6935cc23413804d6a75" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.impl.security.crypto.MerkleTree.maxDepth </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the maximum depth of this <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html" title="Implementation of a Merkle hash tree.">MerkleTree</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the depth </dd></dl>

</div>
</div>
<a class="anchor" id="a91cace4bd02959445ade0ad8708e9267"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::maxDepth" ref="a91cace4bd02959445ade0ad8708e9267" args="(int numLeaves)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int org.ccnx.ccn.impl.security.crypto.MerkleTree.maxDepth </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numLeaves</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>What is the maximum depth of a Merkle tree with a given number of leaves. </p>
<p>If the tree isn't balanced, many nodes may have shorter paths than maxDepth. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>numLeaves</em>&nbsp;</td><td>the number of leaves in the tree. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the maximum depth of the tree </dd></dl>

</div>
</div>
<a class="anchor" id="a48314bda32e60d25cb68e175d2b084eb"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::maxPathLength" ref="a48314bda32e60d25cb68e175d2b084eb" args="(int nodeIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int org.ccnx.ccn.impl.security.crypto.MerkleTree.maxPathLength </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nodeIndex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>What is the maximum path length to a node with this node index, including its sibling but not including the root? </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nodeIndex</em>&nbsp;</td><td>the node to find the path length for </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the maximum path length </dd></dl>

</div>
</div>
<a class="anchor" id="acf85950f5d163b7957e9a620aa7c0d7d"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::nodeCount" ref="acf85950f5d163b7957e9a620aa7c0d7d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.impl.security.crypto.MerkleTree.nodeCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculates the number of nodes in this tree. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of nodes </dd></dl>

</div>
</div>
<a class="anchor" id="ac423384c1216c3d54de7feb7dcb0b5fe"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::nodeCount" ref="ac423384c1216c3d54de7feb7dcb0b5fe" args="(int numLeaves)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int org.ccnx.ccn.impl.security.crypto.MerkleTree.nodeCount </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numLeaves</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the number of nodes in a tree with a given number of leaves. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>numLeaves</em>&nbsp;</td><td>the number of leaves </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of nodes in the tree </dd></dl>

</div>
</div>
<a class="anchor" id="acf1874ddd7399eae4bfdf7d61042a278"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::numLeaves" ref="acf1874ddd7399eae4bfdf7d61042a278" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.impl.security.crypto.MerkleTree.numLeaves </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the number of leaves in the tree. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns the number of leaves </dd></dl>

</div>
</div>
<a class="anchor" id="acbf9cff7981fa74b3197fb1541630384"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::parent" ref="acbf9cff7981fa74b3197fb1541630384" args="(int nodeIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int org.ccnx.ccn.impl.security.crypto.MerkleTree.parent </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nodeIndex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the index of the parent of this node. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nodeIndex</em>&nbsp;</td><td>is a (1-based) node index whose parent we want to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns 0 if this node has no parent (is the root), otherwise the parent's index </dd></dl>

</div>
</div>
<a class="anchor" id="ad6e2ad75a3276115e28f758257b0c979"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::path" ref="ad6e2ad75a3276115e28f758257b0c979" args="(int leafNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_path.html">MerklePath</a> org.ccnx.ccn.impl.security.crypto.MerkleTree.path </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>leafNum</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_path.html" title="A representation of a path through a MerkleTree.">MerklePath</a> for a given leaf, to use in verifying that leaf. </p>
<p>There are a variety of traversal algorithms for computing/reading Merkle hash trees.</p>
<p>We need to represent the leaves so that the user a) knows what order they come in, and b) also knows which is the leaf being represented. The cheapest way to do that is to represent the leaves in order, and also start out with an indication of whether this leaf is the left or right of the last pair. To make this most general and easy to use, we will represent this path as</p>
<p><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_path.html" title="A representation of a path through a MerkleTree.">MerklePath</a> ::= SEQUENCE { nodeIndex INTEGER, nodes NodeList }</p>
<p>NodeList ::= SEQUENCE OF OCTET STRING</p>
<p>the nodeIndex here is the index of the leaf node in the tree as a whole (not just among the leaves), and the nodes list contains neither the digest of the leaf itself nor the root of the tree.</p>
<p>We could probably save a few bytes by not encoding this as DER, and simply packing in the bytes to represent this data -- this encoding offers a fair amount of ease of parsing and clarity, at the cost of probably 5 + 2*pathLength bytes of overhead, or 20 bytes in typical paths. At some point this may seem too much, and we will move to a more compact encoding.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>leafNum</em>&nbsp;</td><td>the leaf index of the leaf </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_path.html" title="A representation of a path through a MerkleTree.">MerklePath</a> for verifying that leaf </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_path.html" title="A representation of a path through a MerkleTree.">MerklePath</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7b10a21605afec5c73f0b9aa79dc131b"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::rightChild" ref="a7b10a21605afec5c73f0b9aa79dc131b" args="(int nodeIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.impl.security.crypto.MerkleTree.rightChild </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nodeIndex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the index of the right child of a given node. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nodeIndex</em>&nbsp;</td><td>the (1-based) index of the node whose child we want to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the index of the right child, or <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#ac9a3e1148f61edcbe0e2aab2136017bb" title="Get the size of the tree, in nodes.">size()</a> if no left child. </dd></dl>

</div>
</div>
<a class="anchor" id="adc1c3a2a29093e7036ff9fdff3ea3ad7"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::root" ref="adc1c3a2a29093e7036ff9fdff3ea3ad7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte [] org.ccnx.ccn.impl.security.crypto.MerkleTree.root </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the root digest. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the root digest </dd></dl>

</div>
</div>
<a class="anchor" id="a05c89eb35fd3dbfddb3c50c1761d5160"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::sibling" ref="a05c89eb35fd3dbfddb3c50c1761d5160" args="(int nodeIndex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int org.ccnx.ccn.impl.security.crypto.MerkleTree.sibling </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nodeIndex</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the index of this node's sibling. </p>
<p>Everything always has a sibling, in this formulation of (not-necessarily-complete binary trees). For root, returns 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>nodeIndex</em>&nbsp;</td><td>the (1-based) index of the node whose sibling we want to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the (1-based) index of the sibling, or 0 for if nodeIndex is the root. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9a3e1148f61edcbe0e2aab2136017bb"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::size" ref="ac9a3e1148f61edcbe0e2aab2136017bb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.impl.security.crypto.MerkleTree.size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the size of the tree, in nodes. </p>
<p>(This is the number of nodes, not the number of leaves.) </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the tree size. </dd></dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ae230a60612dfc034d395425428be13fb"></a><!-- doxytag: member="org::ccnx::ccn::impl::security::crypto::MerkleTree::MERKLE_OID_PREFIX" ref="ae230a60612dfc034d395425428be13fb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final String <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_merkle_tree.html#ae230a60612dfc034d395425428be13fb">org.ccnx.ccn.impl.security.crypto.MerkleTree.MERKLE_OID_PREFIX</a> = &quot;1.2.840.113550.11.1.2&quot;<code> [static, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The OID prefix we use to represent Merkle trees. </p>
<p>Derived from PARC-s sub-arc of Xerox's OID. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/org/ccnx/ccn/impl/security/crypto/MerkleTree.java</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Thu Nov 4 13:34:27 2010 for Content-Centric Networking in Java by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
