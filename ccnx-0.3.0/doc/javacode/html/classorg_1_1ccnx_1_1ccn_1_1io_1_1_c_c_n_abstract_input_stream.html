<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Content-Centric Networking in Java: org.ccnx.ccn.io.CCNAbstractInputStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>org</b>.<b>ccnx</b>.<b>ccn</b>.<b>io</b>.<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html">CCNAbstractInputStream</a>
  </div>
</div>
<div class="contents">
<h1>org.ccnx.ccn.io.CCNAbstractInputStream Class Reference</h1><!-- doxytag: class="org::ccnx::ccn::io::CCNAbstractInputStream" --><!-- doxytag: inherits="java::io::InputStream,org::ccnx::ccn::ContentVerifier,org::ccnx::ccn::CCNInterestListener" -->
<p>This abstract class is the superclass of all classes representing an input stream of bytes segmented and stored in CCN.  
<a href="#_details">More...</a></p>

<p><a href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>IncomingSegment</b></td></tr>
<tr><td colspan="2"><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><b>FlagTypes</b> { <b>DONT_DEREFERENCE</b>
 }</td></tr>
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a679af4d242d9708d60b9ac35b39e7295">CCNAbstractInputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, Long startingSegmentNumber, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys, EnumSet&lt; FlagTypes &gt; flags, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up an input stream to read segmented CCN content under a given name.  <a href="#a679af4d242d9708d60b9ac35b39e7295"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a35265e194f7b012c7630cf004ae7ce20">CCNAbstractInputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> startingSegment, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys, EnumSet&lt; FlagTypes &gt; flags, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException  </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up an input stream to read segmented CCN content starting with a given ContentObject that has already been retrieved.  <a href="#a35265e194f7b012c7630cf004ae7ce20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a776948fb6f7b042b225b3e33629fd831"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::readerReadyCheck" ref="a776948fb6f7b042b225b3e33629fd831" args="(long nextSegment)" -->
boolean&nbsp;</td><td class="memItemRight" valign="bottom"><b>readerReadyCheck</b> (long nextSegment)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_interest.html">Interest</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#ad5ecb037d7825ccba9cad53f88f355a0">handleContent</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> result, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_interest.html">Interest</a> interest)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callback called when we get new results for our query.  <a href="#ad5ecb037d7825ccba9cad53f88f355a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a132af4fe5035a202b3dff1537c9b2fc3">setTimeout</a> (int timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the timeout that will be used for all content retrievals on this stream.  <a href="#a132af4fe5035a202b3dff1537c9b2fc3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a6fe88394d2250e886bb36effabe6534c">addFlags</a> (EnumSet&lt; FlagTypes &gt; additionalFlags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add flags to this stream.  <a href="#a6fe88394d2250e886bb36effabe6534c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a354b1a5468e9ba5c077a56b914203809">addFlag</a> (FlagTypes additionalFlag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a flag to this stream.  <a href="#a354b1a5468e9ba5c077a56b914203809"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#afb41bd0f70183386c648ec981006801f">setFlags</a> (EnumSet&lt; FlagTypes &gt; flags)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set flags on this stream.  <a href="#afb41bd0f70183386c648ec981006801f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36a1d76e6cb99b789672b4a1a12bd572"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::clearFlags" ref="a36a1d76e6cb99b789672b4a1a12bd572" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a36a1d76e6cb99b789672b4a1a12bd572">clearFlags</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clear the flags on this stream. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6656b394e8ee9e270010116ec2457be1"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::removeFlag" ref="a6656b394e8ee9e270010116ec2457be1" args="(FlagTypes flag)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a6656b394e8ee9e270010116ec2457be1">removeFlag</a> (FlagTypes flag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove a flag from this stream. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e3715e5faa5b2edd0630a25e343e868"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::hasFlag" ref="a4e3715e5faa5b2edd0630a25e343e868" args="(FlagTypes flag)" -->
boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a4e3715e5faa5b2edd0630a25e343e868">hasFlag</a> (FlagTypes flag)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check whether this stream has a particular flag set. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a75f44208b7eae91071f22da670f31c21">getBaseName</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#afb7894783052916100a9cf671f83f386">getVersion</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a4154b8b66e6b65d4d6d067e43bb7167a">getFirstDigest</a> ()  throws NoMatchingContentFoundException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the digest of the first segment of this stream.  <a href="#a4154b8b66e6b65d4d6d067e43bb7167a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abe92a970c1251aa58beb6e6f5324d4b8"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::read" ref="abe92a970c1251aa58beb6e6f5324d4b8" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>read</b> ()  throws IOException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af42eeb29ab85334d41200d2a94f581e6"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::read" ref="af42eeb29ab85334d41200d2a94f581e6" args="(byte[] b)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>read</b> (byte[] b)  throws IOException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad68a2b58b10fa3d418fa3ec5920e7553"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::read" ref="ad68a2b58b10fa3d418fa3ec5920e7553" args="(byte[] buf, int offset, int len)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>read</b> (byte[] buf, int offset, int len)  throws IOException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#ac935dca45b37e41d2d11e2bffd90374c">getFirstSegment</a> ()  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the first segment of the stream, based on specified startingSegmentNumber (see CCNAbstractInputStream(ContentName, Long, PublisherPublicKeyDigest, ContentKeys, CCNHandle)).  <a href="#ac935dca45b37e41d2d11e2bffd90374c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace13d1c91ac1ba236fa395b427463142"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::getDereferencedLink" ref="ace13d1c91ac1ba236fa395b427463142" args="()" -->
synchronized <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_link_1_1_link_object.html">LinkObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#ace13d1c91ac1ba236fa395b427463142">getDereferencedLink</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If we traversed a link to get this object, make it available. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#abd38a1255c5e213621016555a88813d2">verify</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> segment)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Verifies the signature on a segment using cached bulk signature data (from Merkle Hash Trees) if it is available.  <a href="#abd38a1255c5e213621016555a88813d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#ad369f365900a8331deb5af7205d86929">firstSegmentNumber</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first segment number for this stream.  <a href="#ad369f365900a8331deb5af7205d86929"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a4f569c98a6093fda678231e4d1165f25">nextSegmentNumber</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the segment number for the next segment.  <a href="#a4f569c98a6093fda678231e4d1165f25"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a2424d3952696b913631848d5a02d5e21">segmentNumber</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a5d9b510fed5cd95b1c4d5d8af15bf7c0">isGone</a> ()  throws NoMatchingContentFoundException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks to see whether this content has been marked as GONE (deleted).  <a href="#a5d9b510fed5cd95b1c4d5d8af15bf7c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a6d6475c46de88d693b80bbfd62206d9c">deletionInformation</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the single segment of a stream marked as GONE.  <a href="#a6d6475c46de88d693b80bbfd62206d9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#ab6cabfc14759c68cd50211f008142834">publisher</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callers may need to access information about this stream's publisher.  <a href="#ab6cabfc14759c68cd50211f008142834"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#ac5511f9c3ae00a2b62c607805288705d">publisherKeyLocator</a> ()  throws IOException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">String&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a5519bb5f0d4fc29b3200a9fa70b4c0c9">currentSegmentName</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b21a5db65024a856c1ed24f5f558454"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::available" ref="a3b21a5db65024a856c1ed24f5f558454" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>available</b> ()  throws IOException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#ab98fb93d0a06ea5c0624a79f730529bb">eof</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a651a883eacd9bd5e245c13cfba9d0d34"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::close" ref="a651a883eacd9bd5e245c13cfba9d0d34" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>close</b> ()  throws IOException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e2fd922c570586c1dd113504ebe21a1"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::mark" ref="a3e2fd922c570586c1dd113504ebe21a1" args="(int readlimit)" -->
synchronized void&nbsp;</td><td class="memItemRight" valign="bottom"><b>mark</b> (int readlimit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a674164c179269723a55d7f67167982cf"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::markSupported" ref="a674164c179269723a55d7f67167982cf" args="()" -->
boolean&nbsp;</td><td class="memItemRight" valign="bottom"><b>markSupported</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a172d4015c81fa42328c72711241d9936"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::reset" ref="a172d4015c81fa42328c72711241d9936" args="()" -->
synchronized void&nbsp;</td><td class="memItemRight" valign="bottom"><b>reset</b> ()  throws IOException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a588c302669b8dccdf3737d1c9c7ce05b"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::skip" ref="a588c302669b8dccdf3737d1c9c7ce05b" args="(long n)" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><b>skip</b> (long n)  throws IOException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a098c5a243c20596540663f3be8a9dd79">seek</a> (long position)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seek a stream to a specific byte offset from the start.  <a href="#a098c5a243c20596540663f3be8a9dd79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a6798b2f7be10f611e4ab020afdca1dc7">tell</a> ()  throws IOException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#afd70027a5a1bb181420753b8168ac0ca">length</a> ()  throws IOException </td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">abstract int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#af7df1128a8a9761d6ad4a629c3934de0">readInternal</a> (byte[] buf, int offset, int len)  throws IOException</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Actual mechanism used to trigger segment retrieval and perform content reads.  <a href="#af7df1128a8a9761d6ad4a629c3934de0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a2aa202418d3b78454c8b63de44cd4001">setFirstSegment</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> newSegment)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called to set the first segment when opening a stream.  <a href="#a2aa202418d3b78454c8b63de44cd4001"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a4faf7927e2fa5f841aff74076527b1ef">setCurrentSegment</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> newSegment)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up current segment for reading, including preparation for decryption if necessary.  <a href="#a4faf7927e2fa5f841aff74076527b1ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a912ce69259b69b20911bc523d7cb45a4">rewindSegment</a> ()  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rewinds read buffers for current segment to beginning of the segment.  <a href="#a912ce69259b69b20911bc523d7cb45a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a3a44c24040f0a80dc2f2c76442bfb36a">getSegment</a> (long number)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves a specific segment of this stream, indicated by segment number.  <a href="#a3a44c24040f0a80dc2f2c76442bfb36a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#ab2d42e6f552f44fbb2fc53649779659a">hasNextSegment</a> ()  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks whether we might have a next segment.  <a href="#ab2d42e6f552f44fbb2fc53649779659a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#adf92c36f0018224ebc6fb6da04f18f53">getNextSegment</a> ()  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve the next segment of the stream.  <a href="#adf92c36f0018224ebc6fb6da04f18f53"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#ac43efa0e15d9f6f6700ae92d723b430c">isFirstSegment</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> desiredName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> segment)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Method to determine whether a retrieved block is the first segment of this stream (as specified by startingSegmentNumber, (see CCNAbstractInputStream(ContentName, Long, PublisherPublicKeyDigest, ContentKeys, CCNHandle)).  <a href="#ac43efa0e15d9f6f6700ae92d723b430c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a129d5fb04e01964307cc251bdf26726e"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::setDereferencedLink" ref="a129d5fb04e01964307cc251bdf26726e" args="(LinkObject dereferencedLink)" -->
synchronized void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a129d5fb04e01964307cc251bdf26726e">setDereferencedLink</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_link_1_1_link_object.html">LinkObject</a> dereferencedLink)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use only if you know what you are doing. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc16ac9c962e7ab93a6b6435bb7a5510"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::pushDereferencedLink" ref="abc16ac9c962e7ab93a6b6435bb7a5510" args="(LinkObject dereferencedLink)" -->
synchronized void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#abc16ac9c962e7ab93a6b6435bb7a5510">pushDereferencedLink</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_link_1_1_link_object.html">LinkObject</a> dereferencedLink)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Add a LinkObject to the stack we had to dereference to get here. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a3611663e71c90b2a55ebf1fdaab0b70d">currentSegmentNumber</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a15cad7928184959904d201cbce45fe69">segmentCount</a> ()  throws IOException </td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a279240fec34515203706c83ffde0ca87"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_handle" ref="a279240fec34515203706c83ffde0ca87" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a279240fec34515203706c83ffde0ca87">_handle</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flags: DONT_DEREFERENCE to prevent dereferencing in case we are attempting to read a link. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_link_1_1_link_object.html">LinkObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a418f0e9f6035558ea8a23e53eaf1acd3">_dereferencedLink</a> = null</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The Link we dereferenced to get here, if any.  <a href="#a418f0e9f6035558ea8a23e53eaf1acd3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e1b1303536236f395ae0872bda61754"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_flags" ref="a7e1b1303536236f395ae0872bda61754" args="" -->
EnumSet&lt; FlagTypes &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>_flags</b> = EnumSet.noneOf(FlagTypes.class)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a007306a9c6a178d1d7665e542d3c2440"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_currentSegment" ref="a007306a9c6a178d1d7665e542d3c2440" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a007306a9c6a178d1d7665e542d3c2440">_currentSegment</a> = null</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The segment we are currently reading from. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">InputStream&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a2d51b47a4aabf241e33acf1f3a540666">_segmentReadStream</a> = null</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal stream used for buffering reads.  <a href="#a2d51b47a4aabf241e33acf1f3a540666"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab87d133a358bf62a52eb4461468a413d"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_baseName" ref="ab87d133a358bf62a52eb4461468a413d" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#ab87d133a358bf62a52eb4461468a413d">_baseName</a> = null</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The name prefix of the segmented stream we are reading, up to (but not including) a segment number. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab42aa1a68b20400a7da2d3887e91ff15"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_publisher" ref="ab42aa1a68b20400a7da2d3887e91ff15" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#ab42aa1a68b20400a7da2d3887e91ff15">_publisher</a> = null</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The publisher we are looking for, either specified by querier on initial read, or read from previous blocks (for now, we assume that all segments in a stream are created by the same publisher). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a95c26e89ef779e68edd68e2156027bae">_startingSegmentNumber</a> = null</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The segment number to start with.  <a href="#a95c26e89ef779e68edd68e2156027bae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3922070d3b3675cf1f087cfe3f7a71d1"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_timeout" ref="a3922070d3b3675cf1f087cfe3f7a71d1" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a3922070d3b3675cf1f087cfe3f7a71d1">_timeout</a> = SystemConfiguration.getDefaultTimeout()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The timeout to use for segment retrieval. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6d7c84e512dd20ea89b5650f1308b27"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_cipher" ref="af6d7c84e512dd20ea89b5650f1308b27" args="" -->
Cipher&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#af6d7c84e512dd20ea89b5650f1308b27">_cipher</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Encryption/decryption handler. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf51a7744867a7eb65caf79175290a6a"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_keys" ref="acf51a7744867a7eb65caf79175290a6a" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>_keys</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a3c34e92f52bb5f0a28631fe7600725a5">_verifiedRootSignature</a> = null</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If this content uses Merkle Hash Trees or other bulk signatures to amortize signature cost, we can amortize verification cost as well by caching verification data as follows: store the currently-verified root signature, so we don't have to re-verify it; and the verified root hash.  <a href="#a3c34e92f52bb5f0a28631fe7600725a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7da20e4ea1348c4f929f531fd108e109"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_verifiedProxy" ref="a7da20e4ea1348c4f929f531fd108e109" args="" -->
byte[]&nbsp;</td><td class="memItemRight" valign="bottom"><b>_verifiedProxy</b> = null</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc1277951c71b02d2995441b55372024"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_atEOF" ref="adc1277951c71b02d2995441b55372024" args="" -->
boolean&nbsp;</td><td class="memItemRight" valign="bottom"><b>_atEOF</b> = false</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7336cfb9f1fb7ace0e6099618d6a2d45"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_readlimit" ref="a7336cfb9f1fb7ace0e6099618d6a2d45" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a7336cfb9f1fb7ace0e6099618d6a2d45">_readlimit</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Used for mark(int) and reset(). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f2438a2a69f22bd51d023aab52123e0"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_markOffset" ref="a8f2438a2a69f22bd51d023aab52123e0" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>_markOffset</b> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3331668441d2c7c9c1dc9dbcc6877755"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_markBlock" ref="a3331668441d2c7c9c1dc9dbcc6877755" args="" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><b>_markBlock</b> = 0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afb9e3a8b87850a2e10b9e068a988fdaa"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::inOrderSegments" ref="afb9e3a8b87850a2e10b9e068a988fdaa" args="" -->
ArrayList&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>inOrderSegments</b> = new ArrayList&lt;<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&gt;()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab63ba8ee298bc2beb188d60491902406"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::outOfOrderSegments" ref="ab63ba8ee298bc2beb188d60491902406" args="" -->
ArrayList&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>outOfOrderSegments</b> = new ArrayList&lt;<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&gt;()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a606705f92f34596498a4b525ec318a96"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_nextPipelineSegment" ref="a606705f92f34596498a4b525ec318a96" args="" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><b>_nextPipelineSegment</b> = -1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af358ba326c4fbcf854d68aca501cf156"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_lastRequestedPipelineSegment" ref="af358ba326c4fbcf854d68aca501cf156" args="" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><b>_lastRequestedPipelineSegment</b> = -1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35528cdae0c39fc5a304db2b673c3105"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_lastInOrderSegment" ref="a35528cdae0c39fc5a304db2b673c3105" args="" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><b>_lastInOrderSegment</b> = -1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab490996d296b43c7a679ba39c20f428d"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_basePipelineName" ref="ab490996d296b43c7a679ba39c20f428d" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>_basePipelineName</b> = null</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1671ed0f91a686da6e968e9f05e52095"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_lastSegmentNumber" ref="a1671ed0f91a686da6e968e9f05e52095" args="" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><b>_lastSegmentNumber</b> = -1</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad82f9aea7c1b4369c79efbe387f20ae9"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_sentInterests" ref="ad82f9aea7c1b4369c79efbe387f20ae9" args="" -->
ArrayList&lt; <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_interest.html">Interest</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>_sentInterests</b> = new ArrayList&lt;<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_interest.html">Interest</a>&gt;()</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This abstract class is the superclass of all classes representing an input stream of bytes segmented and stored in CCN. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>SegmentationProfile for description of CCN segmentation </dd></dl>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a679af4d242d9708d60b9ac35b39e7295"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::CCNAbstractInputStream" ref="a679af4d242d9708d60b9ac35b39e7295" args="(ContentName baseName, Long startingSegmentNumber, PublisherPublicKeyDigest publisher, ContentKeys keys, EnumSet&lt; FlagTypes &gt; flags, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.CCNAbstractInputStream.CCNAbstractInputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Long&nbsp;</td>
          <td class="paramname"> <em>startingSegmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EnumSet&lt; FlagTypes &gt;&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up an input stream to read segmented CCN content under a given name. </p>
<p>Note that this constructor does not currently retrieve any data; data is not retrieved until read() is called. This will change in the future, and this constructor will retrieve the first block.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>baseName</em>&nbsp;</td><td>Name to read from. If contains a segment number, will start to read from that segment. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startingSegmentNumber</em>&nbsp;</td><td>Alternative specification of starting segment number. If unspecified, will be <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_segmentation_profile.html#acd28bc3d6df1a690f90626a5fe656e85" title="Control whether fragments start at 0 or 1.">SegmentationProfile.baseSegment()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publisher</em>&nbsp;</td><td>The key we require to have signed this content. If null, will accept any publisher (subject to higher-level verification). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>The keys to use to decrypt this content. Null if content unencrypted, or another process will be used to retrieve the keys. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>The CCN handle to use for data retrieval. If null, the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle.getHandle()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>Not currently thrown, will be thrown when constructors retrieve first block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a35265e194f7b012c7630cf004ae7ce20"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::CCNAbstractInputStream" ref="a35265e194f7b012c7630cf004ae7ce20" args="(ContentObject startingSegment, ContentKeys keys, EnumSet&lt; FlagTypes &gt; flags, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.CCNAbstractInputStream.CCNAbstractInputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&nbsp;</td>
          <td class="paramname"> <em>startingSegment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EnumSet&lt; FlagTypes &gt;&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException  </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up an input stream to read segmented CCN content starting with a given ContentObject that has already been retrieved. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startingSegment</em>&nbsp;</td><td>The first segment to read from. If this is not the first segment of the stream, reading will begin from this point. We assume that the signature on this segment was verified by our caller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>The keys to use to decrypt this content. Null if content unencrypted, or another process will be used to retrieve the keys. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>any</em>&nbsp;</td><td>flags necessary for processing this stream; have to hand in in constructor in case first segment provided, so can apply to that segment </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>The CCN handle to use for data retrieval. If null, the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle.getHandle()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a354b1a5468e9ba5c077a56b914203809"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::addFlag" ref="a354b1a5468e9ba5c077a56b914203809" args="(FlagTypes additionalFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.CCNAbstractInputStream.addFlag </td>
          <td>(</td>
          <td class="paramtype">FlagTypes&nbsp;</td>
          <td class="paramname"> <em>additionalFlag</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a flag to this stream. </p>
<p>Adds to existing flags. </p>

</div>
</div>
<a class="anchor" id="a6fe88394d2250e886bb36effabe6534c"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::addFlags" ref="a6fe88394d2250e886bb36effabe6534c" args="(EnumSet&lt; FlagTypes &gt; additionalFlags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.CCNAbstractInputStream.addFlags </td>
          <td>(</td>
          <td class="paramtype">EnumSet&lt; FlagTypes &gt;&nbsp;</td>
          <td class="paramname"> <em>additionalFlags</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add flags to this stream. </p>
<p>Adds to existing flags. </p>

</div>
</div>
<a class="anchor" id="a5519bb5f0d4fc29b3200a9fa70b4c0c9"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::currentSegmentName" ref="a5519bb5f0d4fc29b3200a9fa70b4c0c9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String org.ccnx.ccn.io.CCNAbstractInputStream.currentSegmentName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the name of the current segment held by this string, or "null". Used for debugging. </dd></dl>

</div>
</div>
<a class="anchor" id="a3611663e71c90b2a55ebf1fdaab0b70d"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::currentSegmentNumber" ref="a3611663e71c90b2a55ebf1fdaab0b70d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.io.CCNAbstractInputStream.currentSegmentNumber </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the segment number of the current segment if we have one, otherwise -1. </dd></dl>

</div>
</div>
<a class="anchor" id="a6d6475c46de88d693b80bbfd62206d9c"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::deletionInformation" ref="a6d6475c46de88d693b80bbfd62206d9c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> org.ccnx.ccn.io.CCNAbstractInputStream.deletionInformation </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the single segment of a stream marked as GONE. </p>
<p>This method should be called only after checking <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a5d9b510fed5cd95b1c4d5d8af15bf7c0" title="Checks to see whether this content has been marked as GONE (deleted).">isGone()</a> == true otherwise it may return the wrong result. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the GONE segment or null if state unknown or stream is not marked GONE </dd></dl>

</div>
</div>
<a class="anchor" id="ab98fb93d0a06ea5c0624a79f730529bb"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::eof" ref="ab98fb93d0a06ea5c0624a79f730529bb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.io.CCNAbstractInputStream.eof </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether this stream believes it is at eof (has read past the end of the last segment of the stream). </dd></dl>

</div>
</div>
<a class="anchor" id="ad369f365900a8331deb5af7205d86929"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::firstSegmentNumber" ref="ad369f365900a8331deb5af7205d86929" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.io.CCNAbstractInputStream.firstSegmentNumber </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the first segment number for this stream. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The index of the first segment of stream data. </dd></dl>

</div>
</div>
<a class="anchor" id="a75f44208b7eae91071f22da670f31c21"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::getBaseName" ref="a75f44208b7eae91071f22da670f31c21" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> org.ccnx.ccn.io.CCNAbstractInputStream.getBaseName </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The name used to retrieve segments of this stream (not including the segment number). </dd></dl>

</div>
</div>
<a class="anchor" id="a4154b8b66e6b65d4d6d067e43bb7167a"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::getFirstDigest" ref="a4154b8b66e6b65d4d6d067e43bb7167a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte [] org.ccnx.ccn.io.CCNAbstractInputStream.getFirstDigest </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_no_matching_content_found_exception.html">NoMatchingContentFoundException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the digest of the first segment of this stream. </p>
<p>Together with <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#ad369f365900a8331deb5af7205d86929" title="Returns the first segment number for this stream.">firstSegmentNumber()</a> and <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a75f44208b7eae91071f22da670f31c21">getBaseName()</a> this method may be used to identify the stream content unambiguously.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The digest of the first segment of this stream </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NoMatchingContentException</em>&nbsp;</td><td>if no content available </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>on communication error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac935dca45b37e41d2d11e2bffd90374c"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::getFirstSegment" ref="ac935dca45b37e41d2d11e2bffd90374c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> org.ccnx.ccn.io.CCNAbstractInputStream.getFirstSegment </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the first segment of the stream, based on specified startingSegmentNumber (see CCNAbstractInputStream(ContentName, Long, PublisherPublicKeyDigest, ContentKeys, CCNHandle)). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the first segment, if found. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>If can't get a valid starting segment number </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#aeaf6514a029d8e391cfbe6c16e0bbec2">org.ccnx.ccn.io.CCNFileInputStream</a>, and <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_versioned_input_stream.html#acc23dd6c55bebe65b5eaaa7034258fc5">org.ccnx.ccn.io.CCNVersionedInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="adf92c36f0018224ebc6fb6da04f18f53"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::getNextSegment" ref="adf92c36f0018224ebc6fb6da04f18f53" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> org.ccnx.ccn.io.CCNAbstractInputStream.getNextSegment </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the next segment of the stream. </p>
<p>Convenience method, uses <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a3a44c24040f0a80dc2f2c76442bfb36a" title="Retrieves a specific segment of this stream, indicated by segment number.">getSegment(long)</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the next segment, if found. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a44c24040f0a80dc2f2c76442bfb36a"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::getSegment" ref="a3a44c24040f0a80dc2f2c76442bfb36a" args="(long number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> org.ccnx.ccn.io.CCNAbstractInputStream.getSegment </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>number</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves a specific segment of this stream, indicated by segment number. </p>
<p>Three navigation options: get first (leftmost) segment, get next segment, or get a specific segment. Have to assume that everyone is using our segment number encoding. Probably easier to ask raw streams to use that encoding (e.g. for packet numbers) than to flag streams as to whether they are using integers or segments. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>number</em>&nbsp;</td><td>Segment number to retrieve. See SegmentationProfile for numbering. If we already have this segment as <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a3611663e71c90b2a55ebf1fdaab0b70d">currentSegmentNumber()</a>, will just return the current segment, and will not re-retrieve it from the network. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>If no matching content found (actually throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_no_matching_content_found_exception.html" title="Exception to throw when a data request times out without returning any matching data...">NoMatchingContentFoundException</a>) or if there is an error at lower layers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb7894783052916100a9cf671f83f386"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::getVersion" ref="afb7894783052916100a9cf671f83f386" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a> org.ccnx.ccn.io.CCNAbstractInputStream.getVersion </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>The version of the stream being read, if its name is versioned. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5ecb037d7825ccba9cad53f88f355a0"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::handleContent" ref="ad5ecb037d7825ccba9cad53f88f355a0" args="(ContentObject result, Interest interest)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_interest.html">Interest</a> org.ccnx.ccn.io.CCNAbstractInputStream.handleContent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_interest.html">Interest</a>&nbsp;</td>
          <td class="paramname"> <em>interest</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callback called when we get new results for our query. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>data</em>&nbsp;</td><td>the ContentObject that matched our Interest </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interest</em>&nbsp;</td><td>Interest that was satisfied </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>new Interest to be expressed </dd></dl>

<p>Implements <a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1_c_c_n_interest_listener.html#a9dff8eaa65f047bd74f4f1cc0da9c454">org.ccnx.ccn.CCNInterestListener</a>.</p>

</div>
</div>
<a class="anchor" id="ab2d42e6f552f44fbb2fc53649779659a"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::hasNextSegment" ref="ab2d42e6f552f44fbb2fc53649779659a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.io.CCNAbstractInputStream.hasNextSegment </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether we might have a next segment. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns false if this content is marked as GONE (see ContentType), or if we have retrieved the segment marked as the last one, or, in a very rare case, if we're reading content that does not have segment markers. </dd></dl>

</div>
</div>
<a class="anchor" id="ac43efa0e15d9f6f6700ae92d723b430c"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::isFirstSegment" ref="ac43efa0e15d9f6f6700ae92d723b430c" args="(ContentName desiredName, ContentObject segment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.io.CCNAbstractInputStream.isFirstSegment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>desiredName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&nbsp;</td>
          <td class="paramname"> <em>segment</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Method to determine whether a retrieved block is the first segment of this stream (as specified by startingSegmentNumber, (see CCNAbstractInputStream(ContentName, Long, PublisherPublicKeyDigest, ContentKeys, CCNHandle)). </p>
<p>Overridden by subclasses to implement narrower constraints on names. Once first segment is retrieved, further segments can be identified just by segment-naming conventions (see SegmentationProfile).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>desiredName</em>&nbsp;</td><td>The expected name prefix for the stream. For <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html" title="This abstract class is the superclass of all classes representing an input stream...">CCNAbstractInputStream</a>, assume that desiredName contains the name up to but not including segmentation information. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>segment</em>&nbsp;</td><td>The potential first segment. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if it is the first segment, false otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_versioned_input_stream.html#a96ae6b228bb0db5716d6b24a262dcc9b">org.ccnx.ccn.io.CCNVersionedInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a5d9b510fed5cd95b1c4d5d8af15bf7c0"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::isGone" ref="a5d9b510fed5cd95b1c4d5d8af15bf7c0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.io.CCNAbstractInputStream.isGone </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_no_matching_content_found_exception.html">NoMatchingContentFoundException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks to see whether this content has been marked as GONE (deleted). </p>
<p>Will retrieve the first segment if we do not already have it in order to make this determination. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if stream is GONE. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>NoMatchingContentFound</em>&nbsp;</td><td>exception if no first segment found </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>if there is other difficulty retrieving the first segment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd70027a5a1bb181420753b8168ac0ca"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::length" ref="afd70027a5a1bb181420753b8168ac0ca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.io.CCNAbstractInputStream.length </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Total length of the stream, if known, otherwise -1. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#aa1e9dbd04deda5af0bdf5fad9be4481e">org.ccnx.ccn.io.CCNFileInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a4f569c98a6093fda678231e4d1165f25"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::nextSegmentNumber" ref="a4f569c98a6093fda678231e4d1165f25" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.io.CCNAbstractInputStream.nextSegmentNumber </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the segment number for the next segment. </p>
<p>Default segmentation generates sequentially-numbered stream segments but this method may be overridden in subclasses to perform re-assembly on streams that have been segmented differently. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The index of the next segment of stream data. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6cabfc14759c68cd50211f008142834"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::publisher" ref="ab6cabfc14759c68cd50211f008142834" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> org.ccnx.ccn.io.CCNAbstractInputStream.publisher </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callers may need to access information about this stream's publisher. </p>
<p>We eventually should (TODO) ensure that all the segments we're reading match in publisher information, and cache the verified publisher info. (In particular once we're doing trust calculations, to ensure we do them only once per stream.) But we do verify each segment, so start by pulling what's in the current segment. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the publisher of the data in the stream (either as requested, or once we have data, as observed). </dd></dl>

</div>
</div>
<a class="anchor" id="ac5511f9c3ae00a2b62c607805288705d"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::publisherKeyLocator" ref="ac5511f9c3ae00a2b62c607805288705d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> org.ccnx.ccn.io.CCNAbstractInputStream.publisherKeyLocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>the key locator for this stream's publisher. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>if unable to obtain content (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_no_matching_content_found_exception.html" title="Exception to throw when a data request times out without returning any matching data...">NoMatchingContentFoundException</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7df1128a8a9761d6ad4a629c3934de0"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::readInternal" ref="af7df1128a8a9761d6ad4a629c3934de0" args="(byte[] buf, int offset, int len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">abstract int org.ccnx.ccn.io.CCNAbstractInputStream.readInternal </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException<code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Actual mechanism used to trigger segment retrieval and perform content reads. </p>
<p>Subclasses define different schemes for retrieving content across segments. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>As in read(byte[], int, int). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>As in read(byte[], int, int). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>As in read(byte[], int, int). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>As in read(byte[], int, int). </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>if a segment cannot be retrieved, or there is an error in lower-level segment retrieval mechanisms. Uses subclasses of IOException to help provide more information. In particular, throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_no_matching_content_found_exception.html" title="Exception to throw when a data request times out without returning any matching data...">NoMatchingContentFoundException</a> when no content found within the timeout given. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_block_input_stream.html#a5aafb89047f61636a9c3387256ca5157">org.ccnx.ccn.io.CCNBlockInputStream</a>, and <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_input_stream.html#aeb5e019249132b6fcb99d383a5ca4086">org.ccnx.ccn.io.CCNInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a912ce69259b69b20911bc523d7cb45a4"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::rewindSegment" ref="a912ce69259b69b20911bc523d7cb45a4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.CCNAbstractInputStream.rewindSegment </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rewinds read buffers for current segment to beginning of the segment. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a098c5a243c20596540663f3be8a9dd79"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::seek" ref="a098c5a243c20596540663f3be8a9dd79" args="(long position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.CCNAbstractInputStream.seek </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Seek a stream to a specific byte offset from the start. </p>
<p>Tries to avoid retrieving extra segments. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a50124084c647b4e038ef6e6eb5b3f598">org.ccnx.ccn.io.CCNFileInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a15cad7928184959904d201cbce45fe69"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::segmentCount" ref="a15cad7928184959904d201cbce45fe69" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.io.CCNAbstractInputStream.segmentCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Currently returns 0. Can be optionally overridden by subclasses. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#aa4ae3877bcb6d43e7e8148c2bc1dc168">org.ccnx.ccn.io.CCNFileInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a2424d3952696b913631848d5a02d5e21"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::segmentNumber" ref="a2424d3952696b913631848d5a02d5e21" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.io.CCNAbstractInputStream.segmentNumber </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the segment number of the current segment if we have one, otherwise the expected startingSegmentNumber. </dd></dl>

</div>
</div>
<a class="anchor" id="a4faf7927e2fa5f841aff74076527b1ef"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::setCurrentSegment" ref="a4faf7927e2fa5f841aff74076527b1ef" args="(ContentObject newSegment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.CCNAbstractInputStream.setCurrentSegment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&nbsp;</td>
          <td class="paramname"> <em>newSegment</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up current segment for reading, including preparation for decryption if necessary. </p>
<p>Called after getSegment/getFirstSegment/getNextSegment, which take care of verifying the segment for us. Assumes newSegment has been verified. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>If decryption keys set up incorrectly </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2aa202418d3b78454c8b63de44cd4001"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::setFirstSegment" ref="a2aa202418d3b78454c8b63de44cd4001" args="(ContentObject newSegment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.CCNAbstractInputStream.setFirstSegment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&nbsp;</td>
          <td class="paramname"> <em>newSegment</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Called to set the first segment when opening a stream. </p>
<p>This does initialization and setup particular to the first segment of a stream. Subclasses should not override unless they really know what they are doing. Calls <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a4faf7927e2fa5f841aff74076527b1ef" title="Set up current segment for reading, including preparation for decryption if necessary...">setCurrentSegment(ContentObject)</a> for the first segment. If the content is encrypted, and keys are not provided for this stream, they are looked up according to the namespace. Note that this assumes that all segments of a given piece of content are either encrypted or not. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newSegment</em>&nbsp;</td><td>Must not be null </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>If newSegment is null or decryption keys set up incorrectly </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb41bd0f70183386c648ec981006801f"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::setFlags" ref="afb41bd0f70183386c648ec981006801f" args="(EnumSet&lt; FlagTypes &gt; flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.CCNAbstractInputStream.setFlags </td>
          <td>(</td>
          <td class="paramtype">EnumSet&lt; FlagTypes &gt;&nbsp;</td>
          <td class="paramname"> <em>flags</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set flags on this stream. </p>
<p>Replaces existing flags. </p>

</div>
</div>
<a class="anchor" id="a132af4fe5035a202b3dff1537c9b2fc3"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::setTimeout" ref="a132af4fe5035a202b3dff1537c9b2fc3" args="(int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.CCNAbstractInputStream.setTimeout </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the timeout that will be used for all content retrievals on this stream. </p>
<p>Default is 5 seconds. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td>Milliseconds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6798b2f7be10f611e4ab020afdca1dc7"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::tell" ref="a6798b2f7be10f611e4ab020afdca1dc7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.io.CCNAbstractInputStream.tell </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns position in byte offset. For <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html" title="This abstract class is the superclass of all classes representing an input stream...">CCNAbstractInputStream</a>, provide an inadequate base implementation that returns the offset into the current segment (not the stream as a whole). </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#abb4ac8c8739cf28d55f6baec3658bee1">org.ccnx.ccn.io.CCNFileInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="abd38a1255c5e213621016555a88813d2"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::verify" ref="abd38a1255c5e213621016555a88813d2" args="(ContentObject segment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.io.CCNAbstractInputStream.verify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&nbsp;</td>
          <td class="paramname"> <em>segment</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Verifies the signature on a segment using cached bulk signature data (from Merkle Hash Trees) if it is available. </p>
<p>TODO -- check to see if it matches desired publisher. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>segment</em>&nbsp;</td><td>the segment whose signature to verify in the context of this stream. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1_content_verifier.html#a3776510af1ff30d6dbd10616fdaac685">org.ccnx.ccn.ContentVerifier</a>.</p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a418f0e9f6035558ea8a23e53eaf1acd3"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_dereferencedLink" ref="a418f0e9f6035558ea8a23e53eaf1acd3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_link_1_1_link_object.html">LinkObject</a> <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a418f0e9f6035558ea8a23e53eaf1acd3">org.ccnx.ccn.io.CCNAbstractInputStream._dereferencedLink</a> = null<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The Link we dereferenced to get here, if any. </p>
<p>This may contain a link dereferenced to get to it, and so on. </p>

</div>
</div>
<a class="anchor" id="a2d51b47a4aabf241e33acf1f3a540666"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_segmentReadStream" ref="a2d51b47a4aabf241e33acf1f3a540666" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">InputStream <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a2d51b47a4aabf241e33acf1f3a540666">org.ccnx.ccn.io.CCNAbstractInputStream._segmentReadStream</a> = null<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal stream used for buffering reads. </p>
<p>May include filters. </p>

</div>
</div>
<a class="anchor" id="a95c26e89ef779e68edd68e2156027bae"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_startingSegmentNumber" ref="a95c26e89ef779e68edd68e2156027bae" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Long <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a95c26e89ef779e68edd68e2156027bae">org.ccnx.ccn.io.CCNAbstractInputStream._startingSegmentNumber</a> = null<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The segment number to start with. </p>
<p>If not specified, is <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_segmentation_profile.html#acd28bc3d6df1a690f90626a5fe656e85" title="Control whether fragments start at 0 or 1.">SegmentationProfile.baseSegment()</a>. </p>

</div>
</div>
<a class="anchor" id="a3c34e92f52bb5f0a28631fe7600725a5"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNAbstractInputStream::_verifiedRootSignature" ref="a3c34e92f52bb5f0a28631fe7600725a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte [] <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a3c34e92f52bb5f0a28631fe7600725a5">org.ccnx.ccn.io.CCNAbstractInputStream._verifiedRootSignature</a> = null<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If this content uses Merkle Hash Trees or other bulk signatures to amortize signature cost, we can amortize verification cost as well by caching verification data as follows: store the currently-verified root signature, so we don't have to re-verify it; and the verified root hash. </p>
<p>For each piece of incoming content, see if it aggregates to the same root, if so don't reverify signature. If not, assume it's part of a new tree and change the root. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/org/ccnx/ccn/io/CCNAbstractInputStream.java</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Thu Nov 4 13:34:28 2010 for Content-Centric Networking in Java by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
