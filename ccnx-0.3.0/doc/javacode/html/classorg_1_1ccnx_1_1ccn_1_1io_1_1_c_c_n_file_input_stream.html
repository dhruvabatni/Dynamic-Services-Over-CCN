<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Content-Centric Networking in Java: org.ccnx.ccn.io.CCNFileInputStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>org</b>.<b>ccnx</b>.<b>ccn</b>.<b>io</b>.<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html">CCNFileInputStream</a>
  </div>
</div>
<div class="contents">
<h1>org.ccnx.ccn.io.CCNFileInputStream Class Reference</h1><!-- doxytag: class="org::ccnx::ccn::io::CCNFileInputStream" --><!-- doxytag: inherits="org::ccnx::ccn::io::CCNVersionedInputStream,org::ccnx::ccn::io::content::UpdateListener" -->
<p>A CCN input stream that expects content names to be versioned, and streams to have a Header containing file-level metadata about each stream.  
<a href="#_details">More...</a></p>

<p><a href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a57827c947af57aee681fe62c8347448f">CCNFileInputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up an input stream to read segmented CCN content under a given versioned name.  <a href="#a57827c947af57aee681fe62c8347448f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#af098141cd5f3bdeeb1b82673a8745836">CCNFileInputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up an input stream to read segmented CCN content under a given versioned name.  <a href="#af098141cd5f3bdeeb1b82673a8745836"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a97c27d0333346ebc97f40d0cead4afd7">CCNFileInputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up an input stream to read segmented CCN content under a given versioned name.  <a href="#a97c27d0333346ebc97f40d0cead4afd7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#aee70ab5deb2ffd48764994f7c9cbe5ba">CCNFileInputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, Long startingSegmentNumber, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up an input stream to read segmented CCN content under a given versioned name.  <a href="#aee70ab5deb2ffd48764994f7c9cbe5ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#ac0253e55d4dac87dd91bd7b4f2609cc5">CCNFileInputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, Long startingSegmentNumber, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up an input stream to read segmented CCN content under a given versioned name.  <a href="#ac0253e55d4dac87dd91bd7b4f2609cc5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a2b1d4a8f807e6adeca649221432a5485">CCNFileInputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, Long startingSegmentNumber, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up an input stream to read segmented CCN content under a given versioned name.  <a href="#a2b1d4a8f807e6adeca649221432a5485"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a48c2f87ac9121e36182bc48bf2338bad">CCNFileInputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> startingSegment, EnumSet&lt; FlagTypes &gt; flags, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up an input stream to read segmented CCN content starting with a given ContentObject that has already been retrieved.  <a href="#a48c2f87ac9121e36182bc48bf2338bad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a029e84ecb61d87ac6c0832f08848ab91">CCNFileInputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> startingSegment, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys, EnumSet&lt; FlagTypes &gt; flags, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set up an input stream to read segmented CCN content starting with a given ContentObject that has already been retrieved.  <a href="#a029e84ecb61d87ac6c0832f08848ab91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a1e9de63ff5ca69034a00e4fcd2a901b9">hasHeader</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#aeb8062eebface52c802b509ab4e9c3a1">waitForHeader</a> (Long timeout)  throws ContentNotReadyException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Callers who wish to access the header should call this first; it will wait until the header has been successfully retrieved (if the retrieval has started).  <a href="#aeb8062eebface52c802b509ab4e9c3a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1534fd91c2cba6e06512f402c23215ff"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::waitForHeader" ref="a1534fd91c2cba6e06512f402c23215ff" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>waitForHeader</b> ()  throws ContentNotReadyException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html">Header</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a7185356f945852996447c577dd97a9e1">header</a> ()  throws ContentNotReadyException, ContentGoneException, ErrorStateException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Accesses the header data if it has been requested.  <a href="#a7185356f945852996447c577dd97a9e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeaf6514a029d8e391cfbe6c16e0bbec2"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::getFirstSegment" ref="aeaf6514a029d8e391cfbe6c16e0bbec2" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#aeaf6514a029d8e391cfbe6c16e0bbec2">getFirstSegment</a> ()  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Once we have retrieved the first segment of this stream using <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_versioned_input_stream.html#acc23dd6c55bebe65b5eaaa7034258fc5" title="Implementation of getFirstSegment() that expects segments to be versioned.">CCNVersionedInputStream.getFirstSegment()</a>, initiate header retrieval. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a230a4b96838ba8a37f66b5bcd28a41b1"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::skip" ref="a230a4b96838ba8a37f66b5bcd28a41b1" args="(long n)" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><b>skip</b> (long n)  throws IOException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a50124084c647b4e038ef6e6eb5b3f598">seek</a> (long position)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Seek a stream to a specific byte offset from the start.  <a href="#a50124084c647b4e038ef6e6eb5b3f598"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#abb4ac8c8739cf28d55f6baec3658bee1">tell</a> ()  throws IOException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#aa1e9dbd04deda5af0bdf5fad9be4481e">length</a> ()  throws IOException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a1d9f4a53b950a0f04796426a520bd15c">newVersionAvailable</a> (CCNNetworkObject&lt;?&gt; newVersion, boolean wasSave)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notification when a new version is available of a given object (the object's data and version information will already have been updated to reflect the new version).  <a href="#a1d9f4a53b950a0f04796426a520bd15c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35e0d84b314a3c08693cccc3491cbbb3"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::close" ref="a35e0d84b314a3c08693cccc3491cbbb3" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>close</b> ()  throws IOException</td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">boolean&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#ac6dd4335489c463be0dd8521290f2ce8">headerRequested</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#a0aa351af0773d67548531f18750de966">requestHeader</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher)  throws ContentDecodingException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request the header in the background.  <a href="#a0aa351af0773d67548531f18750de966"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#aa4ae3877bcb6d43e7e8148c2bc1dc168">segmentCount</a> ()  throws IOException </td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa07014a60dbf1bb9c76818a2dea6f4bb"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::_header" ref="aa07014a60dbf1bb9c76818a2dea6f4bb" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header_1_1_header_object.html">HeaderObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#aa07014a60dbf1bb9c76818a2dea6f4bb">_header</a> = null</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The header information for that object, once we've read it. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header_1_1_header_object.html">HeaderObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#ac84483cc5ef6cc945666b9ccbaab1495">_oldHeader</a> = null</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Temporary backwards-compatibility move.  <a href="#ac84483cc5ef6cc945666b9ccbaab1495"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>A CCN input stream that expects content names to be versioned, and streams to have a Header containing file-level metadata about each stream. </p>
<p>See <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_versioned_input_stream.html" title="A CCNInputStream that reads and writes versioned streams.">CCNVersionedInputStream</a> for a description of versioning behavior, and <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_output_stream.html" title="A versioned output stream that adds a header containing file-level metadata to every...">CCNFileOutputStream</a> for a description of header information. The header is read asynchronously, and may not be available at all until the complete stream has been written (in other words, the publisher typically writes the header last). Stream data can be read normally before the header has been read, and the consumer may opt to ignore the header completely, in which case this acts exactly like a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_versioned_input_stream.html" title="A CCNInputStream that reads and writes versioned streams.">CCNVersionedInputStream</a>. In fact, a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_versioned_input_stream.html" title="A CCNInputStream that reads and writes versioned streams.">CCNVersionedInputStream</a> can be used to read data read by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_output_stream.html" title="A versioned output stream that adds a header containing file-level metadata to every...">CCNFileOutputStream</a> (except for the header). Using a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html" title="A CCN input stream that expects content names to be versioned, and streams to have...">CCNFileInputStream</a> to read something not written by a <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_output_stream.html" title="A versioned output stream that adds a header containing file-level metadata to every...">CCNFileOutputStream</a> or one of its subclasses (in other words, something without a header) will still try to retrieve the (nonexistent) header in the background, but will not cause an error unless someone tries to access the header data itself.</p>
<p>Headers are named according to definitions in the SegmentationProfile. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a57827c947af57aee681fe62c8347448f"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::CCNFileInputStream" ref="a57827c947af57aee681fe62c8347448f" args="(ContentName baseName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.CCNFileInputStream.CCNFileInputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>baseName</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up an input stream to read segmented CCN content under a given versioned name. </p>
<p>Content is assumed to be unencrypted, or keys will be retrieved automatically via another process. Will use the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle.getHandle()</a>. Note that this constructor does not currently retrieve any data; data is not retrieved until read() is called. This will change in the future, and this constructor will retrieve the first block.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>baseName</em>&nbsp;</td><td>Name to read from. If it ends with a version, will retrieve that specific version. If not, will find the latest version available. If it ends with both a version and a segment number, will start to read from that segment of that version. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>Not currently thrown, will be thrown when constructors retrieve first block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af098141cd5f3bdeeb1b82673a8745836"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::CCNFileInputStream" ref="af098141cd5f3bdeeb1b82673a8745836" args="(ContentName baseName, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.CCNFileInputStream.CCNFileInputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up an input stream to read segmented CCN content under a given versioned name. </p>
<p>Content is assumed to be unencrypted, or keys will be retrieved automatically via another process. Will use the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle.getHandle()</a>. Note that this constructor does not currently retrieve any data; data is not retrieved until read() is called. This will change in the future, and this constructor will retrieve the first block.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>baseName</em>&nbsp;</td><td>Name to read from. If it ends with a version, will retrieve that specific version. If not, will find the latest version available. If it ends with both a version and a segment number, will start to read from that segment of that version. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>The CCN handle to use for data retrieval. If null, the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle.getHandle()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>Not currently thrown, will be thrown when constructors retrieve first block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97c27d0333346ebc97f40d0cead4afd7"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::CCNFileInputStream" ref="a97c27d0333346ebc97f40d0cead4afd7" args="(ContentName baseName, PublisherPublicKeyDigest publisher, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.CCNFileInputStream.CCNFileInputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up an input stream to read segmented CCN content under a given versioned name. </p>
<p>Content is assumed to be unencrypted, or keys will be retrieved automatically via another process. Will use the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle.getHandle()</a>. Note that this constructor does not currently retrieve any data; data is not retrieved until read() is called. This will change in the future, and this constructor will retrieve the first block.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>baseName</em>&nbsp;</td><td>Name to read from. If it ends with a version, will retrieve that specific version. If not, will find the latest version available. If it ends with both a version and a segment number, will start to read from that segment of that version. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publisher</em>&nbsp;</td><td>The key we require to have signed this content. If null, will accept any publisher (subject to higher-level verification). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>The CCN handle to use for data retrieval. If null, the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle.getHandle()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>Not currently thrown, will be thrown when constructors retrieve first block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee70ab5deb2ffd48764994f7c9cbe5ba"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::CCNFileInputStream" ref="aee70ab5deb2ffd48764994f7c9cbe5ba" args="(ContentName baseName, Long startingSegmentNumber, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.CCNFileInputStream.CCNFileInputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Long&nbsp;</td>
          <td class="paramname"> <em>startingSegmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up an input stream to read segmented CCN content under a given versioned name. </p>
<p>Content is assumed to be unencrypted, or keys will be retrieved automatically via another process. Will use the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle.getHandle()</a>. Note that this constructor does not currently retrieve any data; data is not retrieved until read() is called. This will change in the future, and this constructor will retrieve the first block.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>baseName</em>&nbsp;</td><td>Name to read from. If it ends with a version, will retrieve that specific version. If not, will find the latest version available. If it ends with both a version and a segment number, will start to read from that segment of that version. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startingSegmentNumber</em>&nbsp;</td><td>Alternative specification of starting segment number. If null, will be <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_segmentation_profile.html#acd28bc3d6df1a690f90626a5fe656e85" title="Control whether fragments start at 0 or 1.">SegmentationProfile.baseSegment()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>The CCN handle to use for data retrieval. If null, the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle.getHandle()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>Not currently thrown, will be thrown when constructors retrieve first block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0253e55d4dac87dd91bd7b4f2609cc5"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::CCNFileInputStream" ref="ac0253e55d4dac87dd91bd7b4f2609cc5" args="(ContentName baseName, Long startingSegmentNumber, PublisherPublicKeyDigest publisher, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.CCNFileInputStream.CCNFileInputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Long&nbsp;</td>
          <td class="paramname"> <em>startingSegmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up an input stream to read segmented CCN content under a given versioned name. </p>
<p>Content is assumed to be unencrypted, or keys will be retrieved automatically via another process. Will use the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle.getHandle()</a>. Note that this constructor does not currently retrieve any data; data is not retrieved until read() is called. This will change in the future, and this constructor will retrieve the first block.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>baseName</em>&nbsp;</td><td>Name to read from. If it ends with a version, will retrieve that specific version. If not, will find the latest version available. If it ends with both a version and a segment number, will start to read from that segment of that version. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startingSegmentNumber</em>&nbsp;</td><td>Alternative specification of starting segment number. If null, will be <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_segmentation_profile.html#acd28bc3d6df1a690f90626a5fe656e85" title="Control whether fragments start at 0 or 1.">SegmentationProfile.baseSegment()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publisher</em>&nbsp;</td><td>The key we require to have signed this content. If null, will accept any publisher (subject to higher-level verification). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>The CCN handle to use for data retrieval. If null, the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle.getHandle()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>Not currently thrown, will be thrown when constructors retrieve first block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b1d4a8f807e6adeca649221432a5485"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::CCNFileInputStream" ref="a2b1d4a8f807e6adeca649221432a5485" args="(ContentName baseName, Long startingSegmentNumber, PublisherPublicKeyDigest publisher, ContentKeys keys, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.CCNFileInputStream.CCNFileInputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Long&nbsp;</td>
          <td class="paramname"> <em>startingSegmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up an input stream to read segmented CCN content under a given versioned name. </p>
<p>Will use the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle.getHandle()</a>. Note that this constructor does not currently retrieve any data; data is not retrieved until read() is called. This will change in the future, and this constructor will retrieve the first block.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>baseName</em>&nbsp;</td><td>Name to read from. If it ends with a version, will retrieve that specific version. If not, will find the latest version available. If it ends with both a version and a segment number, will start to read from that segment of that version. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>startingSegmentNumber</em>&nbsp;</td><td>Alternative specification of starting segment number. If null, will be <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_segmentation_profile.html#acd28bc3d6df1a690f90626a5fe656e85" title="Control whether fragments start at 0 or 1.">SegmentationProfile.baseSegment()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publisher</em>&nbsp;</td><td>The key we require to have signed this content. If null, will accept any publisher (subject to higher-level verification). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>The keys to use to decrypt this content. If null, assumes content unencrypted, or another process will be used to retrieve the keys. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>The CCN handle to use for data retrieval. If null, the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle.getHandle()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>Not currently thrown, will be thrown when constructors retrieve first block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a48c2f87ac9121e36182bc48bf2338bad"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::CCNFileInputStream" ref="a48c2f87ac9121e36182bc48bf2338bad" args="(ContentObject startingSegment, EnumSet&lt; FlagTypes &gt; flags, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.CCNFileInputStream.CCNFileInputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&nbsp;</td>
          <td class="paramname"> <em>startingSegment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EnumSet&lt; FlagTypes &gt;&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up an input stream to read segmented CCN content starting with a given ContentObject that has already been retrieved. </p>
<p>Content is assumed to be unencrypted, or keys will be retrieved automatically via another process. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startingSegment</em>&nbsp;</td><td>The first segment to read from. If this is not the first segment of the stream, reading will begin from this point. We assume that the signature on this segment was verified by our caller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>any stream flags that must be set to handle even this first block (otherwise they can be set with setFlags prior to read). Can be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>The CCN handle to use for data retrieval. If null, the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle.getHandle()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a029e84ecb61d87ac6c0832f08848ab91"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::CCNFileInputStream" ref="a029e84ecb61d87ac6c0832f08848ab91" args="(ContentObject startingSegment, ContentKeys keys, EnumSet&lt; FlagTypes &gt; flags, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.CCNFileInputStream.CCNFileInputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&nbsp;</td>
          <td class="paramname"> <em>startingSegment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EnumSet&lt; FlagTypes &gt;&nbsp;</td>
          <td class="paramname"> <em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set up an input stream to read segmented CCN content starting with a given ContentObject that has already been retrieved. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>startingSegment</em>&nbsp;</td><td>The first segment to read from. If this is not the first segment of the stream, reading will begin from this point. We assume that the signature on this segment was verified by our caller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>The keys to use to decrypt this content. Null if content unencrypted, or another process will be used to retrieve the keys. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flags</em>&nbsp;</td><td>any stream flags that must be set to handle even this first block (otherwise they can be set with setFlags prior to read). Can be null. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>The CCN handle to use for data retrieval. If null, the default handle given by <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#a45032ac9ee3bbcdc7fb3b175a247d714" title="Returns a static CCNHandle that is made available as a default.">CCNHandle.getHandle()</a> will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1e9de63ff5ca69034a00e4fcd2a901b9"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::hasHeader" ref="a1e9de63ff5ca69034a00e4fcd2a901b9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.io.CCNFileInputStream.hasHeader </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if we have retrieved the header. </dd></dl>

</div>
</div>
<a class="anchor" id="a7185356f945852996447c577dd97a9e1"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::header" ref="a7185356f945852996447c577dd97a9e1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header.html">Header</a> org.ccnx.ccn.io.CCNFileInputStream.header </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a>, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_gone_exception.html">ContentGoneException</a>, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_error_state_exception.html">ErrorStateException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Accesses the header data if it has been requested. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the Header for this stream. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentNotReadyException</em>&nbsp;</td><td>if we have not retrieved the header yet, or it hasn't been requested. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentGoneException</em>&nbsp;</td><td>if the header has been deleted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_error_state_exception.html" title="Exception to throw when we are asked to pull data from a network object or stream...">ErrorStateException</a></em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac6dd4335489c463be0dd8521290f2ce8"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::headerRequested" ref="ac6dd4335489c463be0dd8521290f2ce8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean org.ccnx.ccn.io.CCNFileInputStream.headerRequested </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>true if we have started the header retrieval process. To begin the process, we must first know what version of the content we are reading. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1e9dbd04deda5af0bdf5fad9be4481e"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::length" ref="aa1e9dbd04deda5af0bdf5fad9be4481e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.io.CCNFileInputStream.length </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Total length of the stream, if known, otherwise -1. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#afd70027a5a1bb181420753b8168ac0ca">org.ccnx.ccn.io.CCNAbstractInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a1d9f4a53b950a0f04796426a520bd15c"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::newVersionAvailable" ref="a1d9f4a53b950a0f04796426a520bd15c" args="(CCNNetworkObject&lt;?&gt; newVersion, boolean wasSave)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.CCNFileInputStream.newVersionAvailable </td>
          <td>(</td>
          <td class="paramtype">CCNNetworkObject&lt;?&gt;&nbsp;</td>
          <td class="paramname"> <em>newVersion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>wasSave</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notification when a new version is available of a given object (the object's data and version information will already have been updated to reflect the new version). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newVersion</em>&nbsp;</td><td>The newly updated object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wasSave</em>&nbsp;</td><td>If true, someone called save() on this particular object, if false, the object received new data from the network. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_update_listener.html#a459fc1563a2754b5212ec1205c8dae14">org.ccnx.ccn.io.content.UpdateListener</a>.</p>

</div>
</div>
<a class="anchor" id="a0aa351af0773d67548531f18750de966"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::requestHeader" ref="a0aa351af0773d67548531f18750de966" args="(ContentName baseName, PublisherPublicKeyDigest publisher)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.CCNFileInputStream.requestHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_decoding_exception.html">ContentDecodingException</a>, IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request the header in the background. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>baseName</em>&nbsp;</td><td>name of the content, including the version, from which the header name will be derived. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publisher</em>&nbsp;</td><td>expected publisher </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>If the header cannot be retrieved. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentDecodingException</em>&nbsp;</td><td>If the header cannot be decoded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50124084c647b4e038ef6e6eb5b3f598"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::seek" ref="a50124084c647b4e038ef6e6eb5b3f598" args="(long position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.CCNFileInputStream.seek </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Seek a stream to a specific byte offset from the start. </p>
<p>Tries to avoid retrieving extra segments. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a098c5a243c20596540663f3be8a9dd79">org.ccnx.ccn.io.CCNAbstractInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="aa4ae3877bcb6d43e7e8148c2bc1dc168"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::segmentCount" ref="aa4ae3877bcb6d43e7e8148c2bc1dc168" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.io.CCNFileInputStream.segmentCount </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Currently returns 0. Can be optionally overridden by subclasses. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a15cad7928184959904d201cbce45fe69">org.ccnx.ccn.io.CCNAbstractInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="abb4ac8c8739cf28d55f6baec3658bee1"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::tell" ref="abb4ac8c8739cf28d55f6baec3658bee1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.io.CCNFileInputStream.tell </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns position in byte offset. For <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html" title="This abstract class is the superclass of all classes representing an input stream...">CCNAbstractInputStream</a>, provide an inadequate base implementation that returns the offset into the current segment (not the stream as a whole). </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_input_stream.html#a6798b2f7be10f611e4ab020afdca1dc7">org.ccnx.ccn.io.CCNAbstractInputStream</a>.</p>

</div>
</div>
<a class="anchor" id="aeb8062eebface52c802b509ab4e9c3a1"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::waitForHeader" ref="aeb8062eebface52c802b509ab4e9c3a1" args="(Long timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.CCNFileInputStream.waitForHeader </td>
          <td>(</td>
          <td class="paramtype">Long&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_not_ready_exception.html">ContentNotReadyException</a> </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Callers who wish to access the header should call this first; it will wait until the header has been successfully retrieved (if the retrieval has started). </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ContentNotReadyException</em>&nbsp;</td><td>if we have not requested the header yet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="ac84483cc5ef6cc945666b9ccbaab1495"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNFileInputStream::_oldHeader" ref="ac84483cc5ef6cc945666b9ccbaab1495" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_header_1_1_header_object.html">HeaderObject</a> <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_input_stream.html#ac84483cc5ef6cc945666b9ccbaab1495">org.ccnx.ccn.io.CCNFileInputStream._oldHeader</a> = null<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Temporary backwards-compatibility move. </p>
<p>.. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/org/ccnx/ccn/io/CCNFileInputStream.java</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Thu Nov 4 13:34:28 2010 for Content-Centric Networking in Java by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
