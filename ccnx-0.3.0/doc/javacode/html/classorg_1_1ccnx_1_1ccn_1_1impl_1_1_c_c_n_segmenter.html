<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Content-Centric Networking in Java: org.ccnx.ccn.impl.CCNSegmenter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>org</b>.<b>ccnx</b>.<b>ccn</b>.<b>impl</b>.<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html">CCNSegmenter</a>
  </div>
</div>
<div class="contents">
<h1>org.ccnx.ccn.impl.CCNSegmenter Class Reference</h1><!-- doxytag: class="org::ccnx::ccn::impl::CCNSegmenter" -->
<p>Combines segmentation, signing and encryption.  
<a href="#_details">More...</a></p>

<p><a href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a6270483ef281895470732b058c67cb68">CCNSegmenter</a> ()  throws ConfigurationException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a segmenter with default (Merkle hash tree) bulk signing behavior, making a new handle for it to use.  <a href="#a6270483ef281895470732b058c67cb68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a897605a8a0b8362cdab1148822d6f824">CCNSegmenter</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a segmenter with default (Merkle hash tree) bulk signing behavior.  <a href="#a897605a8a0b8362cdab1148822d6f824"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a7f4de398987fee9331bb1ef65c4ebc59">CCNSegmenter</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a> flowControl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a segmenter with default (Merkle hash tree) bulk signing behavior.  <a href="#a7f4de398987fee9331bb1ef65c4ebc59"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a67d2dd38c5b73daf51d3d68585dca62f">CCNSegmenter</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a> flowControl, <a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_c_c_n_aggregated_signer.html">CCNAggregatedSigner</a> signer)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a segmenter, specifying the signing behavior to use.  <a href="#a67d2dd38c5b73daf51d3d68585dca62f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab255206910eaf5c8dfa8ad9b687f224"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::getLibrary" ref="aab255206910eaf5c8dfa8ad9b687f224" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getLibrary</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3fb6114fc0f884661bc0ba6b91d0873"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::getFlowControl" ref="ac3fb6114fc0f884661bc0ba6b91d0873" args="()" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>getFlowControl</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#ac8f58ebde44d814fab179c03b6a4cc28">getFirstSegment</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the first segment.  <a href="#ac8f58ebde44d814fab179c03b6a4cc28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a06cfa8f913ab06e33ada929528cc65d4">setBlockSize</a> (int blockSize)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the segmentation block size to use.  <a href="#a06cfa8f913ab06e33ada929528cc65d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a4f57d387423dfa4d1503e6a53e03068e">getBlockSize</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current block size.  <a href="#a4f57d387423dfa4d1503e6a53e03068e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bbd8b7bab8d8c1ffab28588749e6807"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::useByteCountSequenceNumbers" ref="a7bbd8b7bab8d8c1ffab28588749e6807" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>useByteCountSequenceNumbers</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab998a96711cbd40e57fa022cc22bcd9b"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::useFixedIncrementSequenceNumbers" ref="ab998a96711cbd40e57fa022cc22bcd9b" args="(int increment)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>useFixedIncrementSequenceNumbers</b> (int increment)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ebce6a81ea68f709564ec21fcc3eead"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::useScaledByteCountSequenceNumbers" ref="a7ebce6a81ea68f709564ec21fcc3eead" args="(int scale)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>useScaledByteCountSequenceNumbers</b> (int scale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa934f0f48433dbb671bbebe1c137983e"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::setSequenceType" ref="aa934f0f48433dbb671bbebe1c137983e" args="(SegmentNumberType seqType)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setSequenceType</b> (SegmentNumberType seqType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#aeef4920f19ba49caf9e3bd4a6952f8fe">setBlockIncrement</a> (int blockIncrement)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the increment between block numbers.  <a href="#aeef4920f19ba49caf9e3bd4a6952f8fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a3a4a8bfb37ee330526da89338506a966">getBlockIncrement</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the increment between block numbers.  <a href="#a3a4a8bfb37ee330526da89338506a966"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49b31e60d5f3a8e5543f3a30ea00b5d4"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::setByteScale" ref="a49b31e60d5f3a8e5543f3a30ea00b5d4" args="(int byteScale)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setByteScale</b> (int byteScale)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8b23e43d491bd75522e7ec83e58021d"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::getByteScale" ref="ae8b23e43d491bd75522e7ec83e58021d" args="()" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>getByteScale</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a6c5b218290df2c29a2ea532d2fb4e9e7">put</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> name, byte[] content, int offset, int length, boolean lastSegments, SignedInfo.ContentType type, Integer freshnessSeconds, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> locator, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys)  throws InvalidKeyException, SignatureException, NoSuchAlgorithmException, IOException, InvalidAlgorithmParameterException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Puts a complete data item, segmenting it if necessary.  <a href="#a6c5b218290df2c29a2ea532d2fb4e9e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a027eca3398093134eba0f4af87659022">fragmentedPut</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> name, long baseSegmentNumber, byte[] content, int offset, int length, int blockWidth, ContentType type, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a> timestamp, Integer freshnessSeconds, Long finalSegmentIndex, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> locator, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys)  throws InvalidKeyException,  			SignatureException, IOException,  			InvalidAlgorithmParameterException, NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Segments content, builds segment names and ContentObjects, signs them, and writes them to the flow controller to go out to the network.  <a href="#a027eca3398093134eba0f4af87659022"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a552e7a88a116e72a7bdb1f92c0d1950f">fragmentedPut</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> name, long baseSegmentNumber, byte contentBlocks[][], int blockCount, int firstBlockIndex, int lastBlockLength, ContentType type, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a> timestamp, Integer freshnessSeconds, Long finalSegmentIndex, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> locator, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys)  throws InvalidKeyException, SignatureException,  			NoSuchAlgorithmException, IOException, InvalidAlgorithmParameterException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Takes pre-segmented content, builds segment names and ContentObjects, signs them, and writes them to the flow controller to go out to the network.  <a href="#a552e7a88a116e72a7bdb1f92c0d1950f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#ae9230fc0c4e7270d80bc92a88a55dc08">putFragment</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> name, long segmentNumber, byte[] content, int offset, int length, ContentType type, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a> timestamp, Integer freshnessSeconds, Long finalSegmentIndex, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> locator, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys)  throws InvalidKeyException, SignatureException,  			NoSuchAlgorithmException, IOException, InvalidAlgorithmParameterException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Puts a single block of content of arbitrary length using a segment naming convention.  <a href="#ae9230fc0c4e7270d80bc92a88a55dc08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a2ad60cb766d3419a5e1e16483f2a36c2">nextSegmentIndex</a> (long lastSegmentNumber, long lastSegmentLength)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Increment segment number according to the numbering profile in force.  <a href="#a2ad60cb766d3419a5e1e16483f2a36c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a42cece4ed08a698e7fa26eb74d2a80e0">lastSegmentIndex</a> (long currentSegmentNumber, long bytesIntervening, int blocksRemaining)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute the index of the last block of a set of segments, according to the numbering profile.  <a href="#a42cece4ed08a698e7fa26eb74d2a80e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a07015cd40f6afaa8818baf63b4537342">setTimeout</a> (int timeout)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the timeout on the contained flow controller.  <a href="#a07015cd40f6afaa8818baf63b4537342"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#afa5cd186cdde6d267642c82fe318b735">outputLength</a> (int inputLength, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">How many content bytes will it take to represent content of length length, including any padding incurred by encryption?  <a href="#afa5cd186cdde6d267642c82fe318b735"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html">CCNSegmenter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#ad88c86629cd8e761c03d76f25757eef3">getBlockSegmenter</a> (int blockSize, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a> flowControl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory method to create a standard segmenter that generates blocks of fixed length in bytes.  <a href="#ad88c86629cd8e761c03d76f25757eef3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html">CCNSegmenter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a4b3385e178bb310da868068c4acf89bc">getScaledByteCountSegmenter</a> (int scale, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a> flowControl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory method to create a standard segmenter that generates blocks of variable length in bytes, whose segment numbers are scaled by a fixed increment.  <a href="#a4b3385e178bb310da868068c4acf89bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html">CCNSegmenter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a1570a8c5b3a3db4505a88e107c654f26">getByteCountSegmenter</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a> flowControl)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Factory method to create a standard segmenter that generates blocks of variable length in bytes, whose segment numbers are scaled by a fixed increment.  <a href="#a1570a8c5b3a3db4505a88e107c654f26"></a><br/></td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0028330031e1300dd5da0eede77c1708"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::PROP_BLOCK_SIZE" ref="a0028330031e1300dd5da0eede77c1708" args="" -->
static final String&nbsp;</td><td class="memItemRight" valign="bottom"><b>PROP_BLOCK_SIZE</b> = &quot;ccn.lib.blocksize&quot;</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcc0a3728721a6e364066a9b31d98231"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::LAST_SEGMENT" ref="afcc0a3728721a6e364066a9b31d98231" args="" -->
static final long&nbsp;</td><td class="memItemRight" valign="bottom"><b>LAST_SEGMENT</b> = Long.valueOf(-1)</td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e894066e42c4e1ead59a881af40552c"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::initializeBlockSize" ref="a7e894066e42c4e1ead59a881af40552c" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>initializeBlockSize</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a408b24e3d72e569510e8544692af9cc4">fragmentedPut</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> name, byte[] content, int offset, int length, Long finalSegmentIndex, SignedInfo.ContentType type, Integer freshnessSeconds, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> locator, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys)  throws InvalidKeyException, SignatureException, NoSuchAlgorithmException,  	IOException, InvalidAlgorithmParameterException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Segments content, builds segment names and ContentObjects, signs them, and writes them to the flow controller to go out to the network.  <a href="#a408b24e3d72e569510e8544692af9cc4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#aa8f04f4d58dd437a9df9faac84654ec4">buildBlocks</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> rootName, long baseSegmentNumber, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_signed_info.html">SignedInfo</a> signedInfo, byte[] content, int offset, int length, int blockWidth, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys)  throws InvalidKeyException, InvalidAlgorithmParameterException, IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper method to build ContentObjects for segments out of a contiguous buffer.  <a href="#aa8f04f4d58dd437a9df9faac84654ec4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>[]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#af44b9914dc566892bf82706ec36e74d9">buildBlocks</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> rootName, long baseSegmentNumber, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_signed_info.html">SignedInfo</a> signedInfo, byte contentBlocks[][], boolean isDigest, int blockCount, int firstBlockIndex, int lastBlockLength, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys)  throws InvalidKeyException, InvalidAlgorithmParameterException, ContentEncodingException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Helper method to construct ContentObjects from pre-segmented blocks.  <a href="#af44b9914dc566892bf82706ec36e74d9"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac8e5a09d9edc5bd1c874f5d3adf0b852"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::_blockSize" ref="ac8e5a09d9edc5bd1c874f5d3adf0b852" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>_blockSize</b> = <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_segmentation_profile.html#a47ec5bad88f59ebc5be6b33a40bcd228">SegmentationProfile.DEFAULT_BLOCKSIZE</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a67778a8f57d33490457d616a2328ae24"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::_blockIncrement" ref="a67778a8f57d33490457d616a2328ae24" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>_blockIncrement</b> = SegmentationProfile.DEFAULT_INCREMENT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b36416d37ca8f6de5e55f3318fddac3"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::_byteScale" ref="a3b36416d37ca8f6de5e55f3318fddac3" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>_byteScale</b> = SegmentationProfile.DEFAULT_SCALE</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2fa6fd11d07658866383bf98a0d5416"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::_sequenceType" ref="ad2fa6fd11d07658866383bf98a0d5416" args="" -->
SegmentNumberType&nbsp;</td><td class="memItemRight" valign="bottom"><b>_sequenceType</b> = SegmentNumberType.SEGMENT_FIXED_INCREMENT</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad18096dcd663bd23feae6d12e27d6a22"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::_handle" ref="ad18096dcd663bd23feae6d12e27d6a22" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>_handle</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a8edd27662c5bf6dc879c917309e0c7"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::_flowControl" ref="a6a8edd27662c5bf6dc879c917309e0c7" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a6a8edd27662c5bf6dc879c917309e0c7">_flowControl</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Eventually may not contain this; callers may access it exogenously. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_c_c_n_aggregated_signer.html">CCNAggregatedSigner</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a0bdb3b5d7333606709c78200478a510c">_bulkSigner</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Handle multi-block amortized signing.  <a href="#a0bdb3b5d7333606709c78200478a510c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0cfa70fd2b9f41c2e813b614e335a34a"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::_firstSegment" ref="a0cfa70fd2b9f41c2e813b614e335a34a" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a0cfa70fd2b9f41c2e813b614e335a34a">_firstSegment</a> = null</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The first segment, useful for obtaining starting segment number and digest to characterize set of segmented content. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Combines segmentation, signing and encryption. </p>
<p>This is used to prepare data for writing out to ccnd. The intent is to provide a user-friendly, efficient, minimum-copy interface, with some <a class="el" href="namespaceorg_1_1ccnx_1_1ccn_1_1impl_1_1support.html" title="PD org.ccnx.ccn.impl.support.">support</a> for extensibility.</p>
<ul>
<li>
<p class="startli">Segmentation is the division of a large piece of content into multiple smaller content objects. A segment component is appended to the content name to distinguish different segments. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1profiles_1_1_segmentation_profile.html" title="We speak in terms of segments, not fragments, as this profile also encompasses packet-oriented...">org.ccnx.ccn.profiles.SegmentationProfile</a></dd></dl>
<p>This class currently supports a range of quite complex segmentation options. At this point, only a subset of these are supported by the higher level org.ccnx.ccn.io interfaces.</p>
<p>Contiguous blocks (fixed or variable size), or sparse blocks, e.g. at various time offsets. Configurations set the numbering scheme. The two interfaces are either contiguous writes, or (for the sparse case), writes of individual segments specified by offset (can be multi-buffered, as may be multiple KB).</p>
<p>Simplest way to handle might be to expect contiguous blocks (either increments or byte count) and remember what we last wrote, so next call gets next value. Clients writing sparse blocks (only byte count or scaled byte count makes sense for this) can override by setting counter on a call.</p>
<p class="endli"></p>
</li>
<li>
Signing Control -- per ContentObject signing with a choice of signature algorithm, or amortized signing. The default is Merkle Hash Tree based amortization, later there will be other options. <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_c_c_n_merkle_tree_signer.html" title="A CCNAggregatedSigner that builds a Merkle hash tree over a set of blocks and signs...">org.ccnx.ccn.impl.security.crypto.CCNMerkleTreeSigner</a></dd></dl>
</li>
<li>
<p class="startli">Stock low-level encryption. -- Given a key K, an IV, and a chosen encryption algorithm segment content so as to meet a desired net data length with potential block expansion, and encrypt.</p>
<p>For this, we use the standard Java encryption mechanisms, augmented by alternative providers (e.g. BouncyCastle for AES-CTR). We just need a Cipher, a SecretKeySpec, and an IvParameterSpec holding the relevant key data.</p>
<p class="endli">For block ciphers, we require a certain amount of extra space in the blocks to accommodate padding (a minimum of 1 bytes for PKCS5 padding, for example). DKS TODO -- deal with the padding and length expansion For the moment, until we deal with padding we use only AES-CTR. </p>
</li>
</ul>
<p>Overall this class attempts to minimize copying of data. Data must be copied into final ContentObjects returned by the signing operations. On the way, it may need to pass through a block encrypter, which may perform local copies. Higher-level constructs, such as streams, may buffer it above. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6270483ef281895470732b058c67cb68"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::CCNSegmenter" ref="a6270483ef281895470732b058c67cb68" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.impl.CCNSegmenter.CCNSegmenter </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1config_1_1_configuration_exception.html">ConfigurationException</a>, IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a segmenter with default (Merkle hash tree) bulk signing behavior, making a new handle for it to use. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ConfigurationException</em>&nbsp;</td><td>if there is a problem creating the handle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>if there is a problem creating the handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a897605a8a0b8362cdab1148822d6f824"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::CCNSegmenter" ref="a897605a8a0b8362cdab1148822d6f824" args="(CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.impl.CCNSegmenter.CCNSegmenter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a segmenter with default (Merkle hash tree) bulk signing behavior. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>the handle to use, will open a new one if null </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>if there is a problem creating the handle </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f4de398987fee9331bb1ef65c4ebc59"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::CCNSegmenter" ref="a7f4de398987fee9331bb1ef65c4ebc59" args="(CCNFlowControl flowControl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.impl.CCNSegmenter.CCNSegmenter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a>&nbsp;</td>
          <td class="paramname"> <em>flowControl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a segmenter with default (Merkle hash tree) bulk signing behavior. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flowControl</em>&nbsp;</td><td>the specified flow controller to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67d2dd38c5b73daf51d3d68585dca62f"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::CCNSegmenter" ref="a67d2dd38c5b73daf51d3d68585dca62f" args="(CCNFlowControl flowControl, CCNAggregatedSigner signer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.impl.CCNSegmenter.CCNSegmenter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a>&nbsp;</td>
          <td class="paramname"> <em>flowControl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_c_c_n_aggregated_signer.html">CCNAggregatedSigner</a>&nbsp;</td>
          <td class="paramname"> <em>signer</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a segmenter, specifying the signing behavior to use. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flowControl</em>&nbsp;</td><td>the specified flow controller to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>signer</em>&nbsp;</td><td>the bulk signer to use. If null, will use default Merkle hash tree behavior. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af44b9914dc566892bf82706ec36e74d9"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::buildBlocks" ref="af44b9914dc566892bf82706ec36e74d9" args="(ContentName rootName, long baseSegmentNumber, SignedInfo signedInfo, byte contentBlocks[][], boolean isDigest, int blockCount, int firstBlockIndex, int lastBlockLength, ContentKeys keys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> [] org.ccnx.ccn.impl.CCNSegmenter.buildBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>rootName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>baseSegmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_signed_info.html">SignedInfo</a>&nbsp;</td>
          <td class="paramname"> <em>signedInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>contentBlocks</em>[][], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>isDigest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>firstBlockIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lastBlockLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, InvalidAlgorithmParameterException, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1content_1_1_content_encoding_exception.html">ContentEncodingException</a> <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper method to construct ContentObjects from pre-segmented blocks. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rootName</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseSegmentNumber</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>signedInfo</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contentBlocks</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>isDigest</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockCount</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>firstBlockIndex</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lastBlockLength</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>the keys to use for encrypting this segment, or null if unencrypted. The specific Key/IV used for this segment will be obtained by calling keys.getSegmentEncryptionCipher(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidAlgorithmParameterException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ContentEncodingException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p><p>Encryption handling much less efficient here. But we're not sure we need this interface, so live with it till we need to improve it.</p>
</p>

</div>
</div>
<a class="anchor" id="aa8f04f4d58dd437a9df9faac84654ec4"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::buildBlocks" ref="aa8f04f4d58dd437a9df9faac84654ec4" args="(ContentName rootName, long baseSegmentNumber, SignedInfo signedInfo, byte[] content, int offset, int length, int blockWidth, ContentKeys keys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> [] org.ccnx.ccn.impl.CCNSegmenter.buildBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>rootName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>baseSegmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_signed_info.html">SignedInfo</a>&nbsp;</td>
          <td class="paramname"> <em>signedInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, InvalidAlgorithmParameterException, IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Helper method to build ContentObjects for segments out of a contiguous buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rootName</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseSegmentNumber</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>signedInfo</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>content</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockWidth</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>the keys to use for encrypting this segment, or null if unencrypted. The specific Key/IV used for this segment will be obtained by calling keys.getSegmentEncryptionCipher(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidAlgorithmParameterException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a552e7a88a116e72a7bdb1f92c0d1950f"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::fragmentedPut" ref="a552e7a88a116e72a7bdb1f92c0d1950f" args="(ContentName name, long baseSegmentNumber, byte contentBlocks[][], int blockCount, int firstBlockIndex, int lastBlockLength, ContentType type, CCNTime timestamp, Integer freshnessSeconds, Long finalSegmentIndex, KeyLocator locator, PublisherPublicKeyDigest publisher, ContentKeys keys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.impl.CCNSegmenter.fragmentedPut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>baseSegmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&nbsp;</td>
          <td class="paramname"> <em>contentBlocks</em>[][], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>firstBlockIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lastBlockLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContentType&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a>&nbsp;</td>
          <td class="paramname"> <em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&nbsp;</td>
          <td class="paramname"> <em>freshnessSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Long&nbsp;</td>
          <td class="paramname"> <em>finalSegmentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>locator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, SignatureException,  			NoSuchAlgorithmException, IOException, InvalidAlgorithmParameterException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Takes pre-segmented content, builds segment names and ContentObjects, signs them, and writes them to the flow controller to go out to the network. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name prefix to use for the segments </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseSegmentNumber</em>&nbsp;</td><td>the segment number to start this batch with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>contentBlocks</em>&nbsp;</td><td>content buffers containing content to put, one buffer per ContentObject </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockCount</em>&nbsp;</td><td>the number of these content buffers to write </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>firstBlockIndex</em>&nbsp;</td><td>the index into the content buffer array to start writing blocks </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lastBlockLength</em>&nbsp;</td><td>the number of bytes of the last block to be written to use -- this allows a fixed set of byte [] to be used to buffer content for segmentation, and still cope with variable-length last blocks </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the type for the content </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>the timestamp for the content </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freshnessSeconds</em>&nbsp;</td><td>the number of seconds this content should be considered fresh, or null to leave unset </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>finalSegmentIndex</em>&nbsp;</td><td>the expected segment number of the last segment of this stream, null to omit, Long(-1) to set as the last segment of this put, whatever its number turns out to be </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locator</em>&nbsp;</td><td>the key locator to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publisher</em>&nbsp;</td><td>the publisher to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>the keys to use for encrypting this segment, or null if unencrypted. The specific Key/IV used for this segment will be obtained by calling keys.getSegmentEncryptionCipher(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns the segment identifier for the next segment to be written, if any. If the caller doesn't want to override this, they can hand this number back to a subsequent call to fragmentedPut. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SignatureException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidAlgorithmParameterException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a408b24e3d72e569510e8544692af9cc4" title="Segments content, builds segment names and ContentObjects, signs them, and writes...">fragmentedPut</a>(ContentName, byte[], int, int, Long, ContentType, Integer, KeyLocator, PublisherPublicKeyDigest) Starts segmentation at segment SegmentationProfile().baseSegment(). </dd></dl>

</div>
</div>
<a class="anchor" id="a027eca3398093134eba0f4af87659022"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::fragmentedPut" ref="a027eca3398093134eba0f4af87659022" args="(ContentName name, long baseSegmentNumber, byte[] content, int offset, int length, int blockWidth, ContentType type, CCNTime timestamp, Integer freshnessSeconds, Long finalSegmentIndex, KeyLocator locator, PublisherPublicKeyDigest publisher, ContentKeys keys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.impl.CCNSegmenter.fragmentedPut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>baseSegmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContentType&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a>&nbsp;</td>
          <td class="paramname"> <em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&nbsp;</td>
          <td class="paramname"> <em>freshnessSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Long&nbsp;</td>
          <td class="paramname"> <em>finalSegmentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>locator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException,  			SignatureException, IOException,  			InvalidAlgorithmParameterException, NoSuchAlgorithmException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Segments content, builds segment names and ContentObjects, signs them, and writes them to the flow controller to go out to the network. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name prefix to use for the segments </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseSegmentNumber</em>&nbsp;</td><td>the segment number to start this batch with </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>content</em>&nbsp;</td><td>content buffer containing content to put </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>offset into buffer at which to start reading content to put </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>number of bytes of buffer to put </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blockWidth</em>&nbsp;</td><td>the block size to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the type for the content </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>the timestamp for the content </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freshnessSeconds</em>&nbsp;</td><td>the number of seconds this content should be considered fresh, or null to leave unset </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>finalSegmentIndex</em>&nbsp;</td><td>the expected segment number of the last segment of this stream, null to omit, Long(-1) to set as the last segment of this put, whatever its number turns out to be </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locator</em>&nbsp;</td><td>the key locator to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publisher</em>&nbsp;</td><td>the publisher to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>the keys to use for encrypting this segment, or null if unencrypted. The specific Key/IV used for this segment will be obtained by calling keys.getSegmentEncryptionCipher(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns the segment identifier for the next segment to be written, if any. If the caller doesn't want to override this, they can hand this number back to a subsequent call to fragmentedPut. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SignatureException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidAlgorithmParameterException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a408b24e3d72e569510e8544692af9cc4" title="Segments content, builds segment names and ContentObjects, signs them, and writes...">fragmentedPut</a>(ContentName, byte[], int, int, Long, ContentType, Integer, KeyLocator, PublisherPublicKeyDigest) Starts segmentation at segment SegmentationProfile().baseSegment(). </dd></dl>

</div>
</div>
<a class="anchor" id="a408b24e3d72e569510e8544692af9cc4"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::fragmentedPut" ref="a408b24e3d72e569510e8544692af9cc4" args="(ContentName name, byte[] content, int offset, int length, Long finalSegmentIndex, SignedInfo.ContentType type, Integer freshnessSeconds, KeyLocator locator, PublisherPublicKeyDigest publisher, ContentKeys keys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.impl.CCNSegmenter.fragmentedPut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Long&nbsp;</td>
          <td class="paramname"> <em>finalSegmentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SignedInfo.ContentType&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&nbsp;</td>
          <td class="paramname"> <em>freshnessSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>locator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, SignatureException, NoSuchAlgorithmException,  	IOException, InvalidAlgorithmParameterException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Segments content, builds segment names and ContentObjects, signs them, and writes them to the flow controller to go out to the network. </p>
<p>Low-level segmentation interface. Assume arguments have been cleaned prior to arrival -- name is not already segmented, type is set, etc.</p>
<p>Starts segmentation at segment SegmentationProfile().baseSegment(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name prefix to use for the segments </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>content</em>&nbsp;</td><td>content buffer containing content to put </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>offset into buffer at which to start reading content to put </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>number of bytes of buffer to put </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>finalSegmentIndex</em>&nbsp;</td><td>the expected segment number of the last segment of this stream, null to omit, Long(-1) to set as the last segment of this put, whatever its number turns out to be </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the type for the content </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freshnessSeconds</em>&nbsp;</td><td>the number of seconds this content should be considered fresh, or null to leave unset </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locator</em>&nbsp;</td><td>the key locator to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publisher</em>&nbsp;</td><td>the publisher to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>the keys to use for encrypting this segment, or null if unencrypted. The specific Key/IV used for this segment will be obtained by calling keys.getSegmentEncryptionCipher(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns the segment identifier for the next segment to be written, if any. If the caller doesn't want to override this, they can hand this number back to a subsequent call to fragmentedPut. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SignatureException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidAlgorithmParameterException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a4a8bfb37ee330526da89338506a966"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::getBlockIncrement" ref="a3a4a8bfb37ee330526da89338506a966" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.impl.CCNSegmenter.getBlockIncrement </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the increment between block numbers. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ad88c86629cd8e761c03d76f25757eef3"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::getBlockSegmenter" ref="ad88c86629cd8e761c03d76f25757eef3" args="(int blockSize, CCNFlowControl flowControl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html">CCNSegmenter</a> org.ccnx.ccn.impl.CCNSegmenter.getBlockSegmenter </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a>&nbsp;</td>
          <td class="paramname"> <em>flowControl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Factory method to create a standard segmenter that generates blocks of fixed length in bytes. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blockSize</em>&nbsp;</td><td>number of bytes to put in each block (the last block will have an odd number of bytes) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flowControl</em>&nbsp;</td><td>the flow controller to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the new segmenter </dd></dl>

</div>
</div>
<a class="anchor" id="a4f57d387423dfa4d1503e6a53e03068e"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::getBlockSize" ref="a4f57d387423dfa4d1503e6a53e03068e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.impl.CCNSegmenter.getBlockSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the current block size. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>block size in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="a1570a8c5b3a3db4505a88e107c654f26"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::getByteCountSegmenter" ref="a1570a8c5b3a3db4505a88e107c654f26" args="(CCNFlowControl flowControl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html">CCNSegmenter</a> org.ccnx.ccn.impl.CCNSegmenter.getByteCountSegmenter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a>&nbsp;</td>
          <td class="paramname"> <em>flowControl</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Factory method to create a standard segmenter that generates blocks of variable length in bytes, whose segment numbers are scaled by a fixed increment. </p>
<p>This could be used, for example to generate segments that had variable number of bytes in each, and naming them by byte offset. NOTE: This is used by CCNBlockInputStream and CCNBlockOutputStream; the other stream classes will not read data generated this way. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flowControl</em>&nbsp;</td><td>the flow controller to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the new segmenter </dd></dl>

</div>
</div>
<a class="anchor" id="ac8f58ebde44d814fab179c03b6a4cc28"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::getFirstSegment" ref="ac8f58ebde44d814fab179c03b6a4cc28" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_object.html">ContentObject</a> org.ccnx.ccn.impl.CCNSegmenter.getFirstSegment </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the first segment. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first segment or null if no segments generated yet </dd></dl>

</div>
</div>
<a class="anchor" id="a4b3385e178bb310da868068c4acf89bc"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::getScaledByteCountSegmenter" ref="a4b3385e178bb310da868068c4acf89bc" args="(int scale, CCNFlowControl flowControl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html">CCNSegmenter</a> org.ccnx.ccn.impl.CCNSegmenter.getScaledByteCountSegmenter </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a>&nbsp;</td>
          <td class="paramname"> <em>flowControl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Factory method to create a standard segmenter that generates blocks of variable length in bytes, whose segment numbers are scaled by a fixed increment. </p>
<p>This could be used, for example to generate segments that had variable number of bytes in each, and naming them by scaling the byte offset by a scale useful to the application - e.g. to end up with millisecond offsets for a video or audio stream, etc. NOTE: the reader infrastructure currently expects incrementing segment numbers; a special stream class is necessary to read data generated this way. That would not be difficult to write. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scale</em>&nbsp;</td><td>multiplier to apply to the byte count before recording it as a sequence number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flowControl</em>&nbsp;</td><td>the flow controller to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the new segmenter </dd></dl>

</div>
</div>
<a class="anchor" id="a42cece4ed08a698e7fa26eb74d2a80e0"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::lastSegmentIndex" ref="a42cece4ed08a698e7fa26eb74d2a80e0" args="(long currentSegmentNumber, long bytesIntervening, int blocksRemaining)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Long org.ccnx.ccn.impl.CCNSegmenter.lastSegmentIndex </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>currentSegmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>bytesIntervening</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blocksRemaining</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compute the index of the last block of a set of segments, according to the numbering profile. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>currentSegmentNumber</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bytesIntervening</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>blocksRemaining</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a2ad60cb766d3419a5e1e16483f2a36c2"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::nextSegmentIndex" ref="a2ad60cb766d3419a5e1e16483f2a36c2" args="(long lastSegmentNumber, long lastSegmentLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.impl.CCNSegmenter.nextSegmentIndex </td>
          <td>(</td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lastSegmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>lastSegmentLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Increment segment number according to the numbering profile in force. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lastSegmentNumber</em>&nbsp;</td><td>the last segment number we emitted </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lastSegmentLength</em>&nbsp;</td><td>the length of the last segment we emitted </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="afa5cd186cdde6d267642c82fe318b735"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::outputLength" ref="afa5cd186cdde6d267642c82fe318b735" args="(int inputLength, ContentKeys keys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.impl.CCNSegmenter.outputLength </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>inputLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>How many content bytes will it take to represent content of length length, including any padding incurred by encryption? </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>inputLength</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the output length </dd></dl>

</div>
</div>
<a class="anchor" id="a6c5b218290df2c29a2ea532d2fb4e9e7"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::put" ref="a6c5b218290df2c29a2ea532d2fb4e9e7" args="(ContentName name, byte[] content, int offset, int length, boolean lastSegments, SignedInfo.ContentType type, Integer freshnessSeconds, KeyLocator locator, PublisherPublicKeyDigest publisher, ContentKeys keys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.impl.CCNSegmenter.put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>lastSegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SignedInfo.ContentType&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&nbsp;</td>
          <td class="paramname"> <em>freshnessSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>locator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, SignatureException, NoSuchAlgorithmException, IOException, InvalidAlgorithmParameterException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Puts a complete data item, segmenting it if necessary. </p>
<p>The assumption of this method is that this single call puts all the blocks of the item; if multiple calls to the segmenter will be required to output an item, use other methods to manage segment identifiers.</p>
<p>If the data is small enough this doesn't fragment. Otherwise, does. If multi-fragment, uses the naming profile and specified bulk signer (default: Merkle Hash Tree) to generate names and signatures. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>the keys to use for encrypting this segment, or null if unencrypted. The specific Key/IV used for this segment will be obtained by calling keys.getSegmentEncryptionCipher(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>ContentObject of the data that was put (in the case of fragmented data, the first fragment is returned). This way the caller can then easily link to the data if they need to, or put again with a different name. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidAlgorithmParameterException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae9230fc0c4e7270d80bc92a88a55dc08"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::putFragment" ref="ae9230fc0c4e7270d80bc92a88a55dc08" args="(ContentName name, long segmentNumber, byte[] content, int offset, int length, ContentType type, CCNTime timestamp, Integer freshnessSeconds, Long finalSegmentIndex, KeyLocator locator, PublisherPublicKeyDigest publisher, ContentKeys keys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.impl.CCNSegmenter.putFragment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>segmentNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContentType&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a>&nbsp;</td>
          <td class="paramname"> <em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer&nbsp;</td>
          <td class="paramname"> <em>freshnessSeconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Long&nbsp;</td>
          <td class="paramname"> <em>finalSegmentIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>locator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws InvalidKeyException, SignatureException,  			NoSuchAlgorithmException, IOException, InvalidAlgorithmParameterException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Puts a single block of content of arbitrary length using a segment naming convention. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>name prefix to use for the object, without the segment number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>segmentNumber</em>&nbsp;</td><td>the segment number to use for this object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>content</em>&nbsp;</td><td>content buffer containing content to put </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>offset into buffer at which to start reading content to put </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>length</em>&nbsp;</td><td>number of bytes of buffer to put </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>the type for the content </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timestamp</em>&nbsp;</td><td>the timestamp for the content </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>freshnessSeconds</em>&nbsp;</td><td>the number of seconds this content should be considered fresh, or null to leave unset </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>finalSegmentIndex</em>&nbsp;</td><td>the expected segment number of the last segment of this stream, null to omit, Long(-1) to set as the last segment of this put, whatever its number turns out to be </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locator</em>&nbsp;</td><td>the key locator to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publisher</em>&nbsp;</td><td>the publisher to use </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>the keys to use for encrypting this segment, or null if unencrypted. The specific Key/IV used for this segment will be obtained by calling keys.getSegmentEncryptionCipher(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>returns the segment identifier for the next segment to be written, if any. If the caller doesn't want to override this, they can hand this number back to a subsequent call to fragmentedPut. </dd></dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SignatureException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidAlgorithmParameterException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeef4920f19ba49caf9e3bd4a6952f8fe"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::setBlockIncrement" ref="aeef4920f19ba49caf9e3bd4a6952f8fe" args="(int blockIncrement)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.impl.CCNSegmenter.setBlockIncrement </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockIncrement</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the increment between block numbers. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blockIncrement</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06cfa8f913ab06e33ada929528cc65d4"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::setBlockSize" ref="a06cfa8f913ab06e33ada929528cc65d4" args="(int blockSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.impl.CCNSegmenter.setBlockSize </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockSize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the segmentation block size to use. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blockSize</em>&nbsp;</td><td>block size in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a07015cd40f6afaa8818baf63b4537342"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::setTimeout" ref="a07015cd40f6afaa8818baf63b4537342" args="(int timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.impl.CCNSegmenter.setTimeout </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the timeout on the contained flow controller. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>timeout</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a0bdb3b5d7333606709c78200478a510c"></a><!-- doxytag: member="org::ccnx::ccn::impl::CCNSegmenter::_bulkSigner" ref="a0bdb3b5d7333606709c78200478a510c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interfaceorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_c_c_n_aggregated_signer.html">CCNAggregatedSigner</a> <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html#a0bdb3b5d7333606709c78200478a510c">org.ccnx.ccn.impl.CCNSegmenter._bulkSigner</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Handle multi-block amortized signing. </p>
<p>If null, default to single-block signing. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/org/ccnx/ccn/impl/CCNSegmenter.java</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Thu Nov 4 13:34:27 2010 for Content-Centric Networking in Java by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
