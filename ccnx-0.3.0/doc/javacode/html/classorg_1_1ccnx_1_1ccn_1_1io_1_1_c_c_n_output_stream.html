<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Content-Centric Networking in Java: org.ccnx.ccn.io.CCNOutputStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>org</b>.<b>ccnx</b>.<b>ccn</b>.<b>io</b>.<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html">CCNOutputStream</a>
  </div>
</div>
<div class="contents">
<h1>org.ccnx.ccn.io.CCNOutputStream Class Reference</h1><!-- doxytag: class="org::ccnx::ccn::io::CCNOutputStream" --><!-- doxytag: inherits="org::ccnx::ccn::io::CCNAbstractOutputStream" -->
<p>Basic output stream class which generates segmented content under a given name prefix.  
<a href="#_details">More...</a></p>

<p><a href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#abd34979ce1272124fd17e1626c3c8c29">CCNOutputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for a simple CCN output stream.  <a href="#abd34979ce1272124fd17e1626c3c8c29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#adaae49bc34ab632ee86c00e4157d851d">CCNOutputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for a simple CCN output stream.  <a href="#adaae49bc34ab632ee86c00e4157d851d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#a94679af4692e2b24d438be27709d094d">CCNOutputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for a simple CCN output stream.  <a href="#a94679af4692e2b24d438be27709d094d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#ad2a82624c7f63ff2851a1a6ab3ec7797">CCNOutputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> locator, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for a simple CCN output stream.  <a href="#ad2a82624c7f63ff2851a1a6ab3ec7797"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#a1f0f7d200ff4347b68fbf7b6f9067ec5">CCNOutputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> locator, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher, ContentType type, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a> handle)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor for a simple CCN output stream.  <a href="#a1f0f7d200ff4347b68fbf7b6f9067ec5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#a96abfba10af60d8e51af7dc178840a7a">CCNOutputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> locator, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher, ContentType type, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a> flowControl)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Low-level constructor used by clients that need to specify flow control behavior.  <a href="#a96abfba10af60d8e51af7dc178840a7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">synchronized void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#ae7aa488dd2f0618cb1308b98f119acfc">setBlockSize</a> (int blockSize)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the segmentation block size to use.  <a href="#ae7aa488dd2f0618cb1308b98f119acfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#acb40d2ebaab380d8fad727bcf70d7822">getBlockSize</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get segmentation block size.  <a href="#acb40d2ebaab380d8fad727bcf70d7822"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2472df01feb6f244d77bfe5de7b8312c"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::setFreshnessSeconds" ref="a2472df01feb6f244d77bfe5de7b8312c" args="(Integer freshnessSeconds)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>setFreshnessSeconds</b> (Integer freshnessSeconds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab058cd958f4c54be84e0bd2c37d61f45"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::close" ref="ab058cd958f4c54be84e0bd2c37d61f45" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>close</b> ()  throws IOException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aad454e453feb5667a0727a92ea0a4a9a"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::flush" ref="aad454e453feb5667a0727a92ea0a4a9a" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>flush</b> ()  throws IOException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16521969d2d71bda4f5f72e27cba9ef0"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::write" ref="a16521969d2d71bda4f5f72e27cba9ef0" args="(byte[] b, int off, int len)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>write</b> (byte[] b, int off, int len)  throws IOException </td></tr>
<tr><td colspan="2"><h2>Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static final int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#a470e6741042f5b5ef64c11890a331678">BLOCK_BUF_COUNT</a> = 128</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Amount of data we keep around prior to forced flush, in terms of segmenter blocks.  <a href="#a470e6741042f5b5ef64c11890a331678"></a><br/></td></tr>
<tr><td colspan="2"><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad33ac3c27f91f751c21d1d1edb253450"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::CCNOutputStream" ref="ad33ac3c27f91f751c21d1d1edb253450" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#ad33ac3c27f91f751c21d1d1edb253450">CCNOutputStream</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Special purpose constructor. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#a84aa0bf722a126566555afb1597a2e0c">CCNOutputStream</a> (<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a> baseName, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a> locator, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a> publisher, ContentType type, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a> keys, <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html">CCNSegmenter</a> segmenter)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Low-level constructor used by subclasses that need to specify segmenter behavior.  <a href="#a84aa0bf722a126566555afb1597a2e0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#a8f766e2d424cbf743029671ef2919858">startWrite</a> ()  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Override in subclasses that need to do something special with start writes (see <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html#a8bfc829a1e6e762e4de36fdefea079e3" title="This is used to indicate that it should start a write for a stream with this name...">CCNFlowControl.startWrite(ContentName, Shape)</a>).  <a href="#a8f766e2d424cbf743029671ef2919858"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#ac002eca85fabe9749eb5b74b51b1965a">flush</a> (boolean flushLastBlock)  throws IOException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal flush.  <a href="#ac002eca85fabe9749eb5b74b51b1965a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">synchronized void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#a0216719604f1f1542814a9dccdc0ac20">writeToNetwork</a> (byte[] buf, long offset, long len)  throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Actually write bytes to the network.  <a href="#a0216719604f1f1542814a9dccdc0ac20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#a40f3978a67ee41603b0fb1dc19c12741">closeNetworkData</a> ()  throws InvalidKeyException, SignatureException, NoSuchAlgorithmException, IOException, InterruptedException </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flush partial hanging block if we have one.  <a href="#a40f3978a67ee41603b0fb1dc19c12741"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">synchronized void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#a0744cadfb3138aaacab118a05b409bee">flushToNetwork</a> (boolean flushLastBlock)  throws InvalidKeyException, SignatureException, NoSuchAlgorithmException, InterruptedException, IOException, InvalidAlgorithmParameterException </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#a06aed0453aadb2b634819b2d0d003f13">lengthWritten</a> ()</td></tr>
<tr><td colspan="2"><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac24694b343201623f74672b809b8b495"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::_totalLength" ref="ac24694b343201623f74672b809b8b495" args="" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#ac24694b343201623f74672b809b8b495">_totalLength</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">elapsed length written <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d8b8dd9b05937873835a070056d8f26"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::_blockOffset" ref="a3d8b8dd9b05937873835a070056d8f26" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#a3d8b8dd9b05937873835a070056d8f26">_blockOffset</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">write pointer - offset into the current write buffer at which to write <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4c277863e72dae5bcbcba6fb755a241"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::_blockIndex" ref="ad4c277863e72dae5bcbcba6fb755a241" args="" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#ad4c277863e72dae5bcbcba6fb755a241">_blockIndex</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">write pointer - current write buffer at which to write <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01e1e084226e7ce047c0b91e4f3c6a81"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::_buffers" ref="a01e1e084226e7ce047c0b91e4f3c6a81" args="" -->
byte[][]&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#a01e1e084226e7ce047c0b91e4f3c6a81">_buffers</a> = null</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">write buffers <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dbda2b5a22de40914055695bc336741"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::_baseNameIndex" ref="a1dbda2b5a22de40914055695bc336741" args="" -->
long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#a1dbda2b5a22de40914055695bc336741">_baseNameIndex</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">base name index of the current set of data to output; incremented according to the segmentation profile. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a54b4c88781b89774922efe1312bc3164"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::_timestamp" ref="a54b4c88781b89774922efe1312bc3164" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_c_c_n_time.html">CCNTime</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#a54b4c88781b89774922efe1312bc3164">_timestamp</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">// timestamp we use for writing, set to time first segment is written <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a567f0ac832580fb76389a635d02d9202"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::_freshnessSeconds" ref="a567f0ac832580fb76389a635d02d9202" args="" -->
Integer&nbsp;</td><td class="memItemRight" valign="bottom"><b>_freshnessSeconds</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af3e8a485b71e2b1bba4908befb50db91"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::_dh" ref="af3e8a485b71e2b1bba4908befb50db91" args="" -->
<a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_c_c_n_digest_helper.html">CCNDigestHelper</a>&nbsp;</td><td class="memItemRight" valign="bottom"><b>_dh</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Basic output stream class which generates segmented content under a given name prefix. </p>
<p>Segment naming is generated according to the SegmentationProfile; by default names are sequentially numbered. Name prefixes are taken as specified (no versions or other information is added by this class). Segments are fixed length (see <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_block_output_stream.html" title="This class acts as a packet-oriented stream of data.">CCNBlockOutputStream</a> for non fixed-length segments). </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abd34979ce1272124fd17e1626c3c8c29"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::CCNOutputStream" ref="abd34979ce1272124fd17e1626c3c8c29" args="(ContentName baseName, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.CCNOutputStream.CCNOutputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor for a simple CCN output stream. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>baseName</em>&nbsp;</td><td>name prefix under which to write content segments </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>if null, new handle created with <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#abbbf4626e10f2d1a2addd1dc5b6a069f" title="Create a new CCNHandle, opening a new connection to the CCN network.">CCNHandle.open()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>if stream setup fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adaae49bc34ab632ee86c00e4157d851d"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::CCNOutputStream" ref="adaae49bc34ab632ee86c00e4157d851d" args="(ContentName baseName, PublisherPublicKeyDigest publisher, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.CCNOutputStream.CCNOutputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor for a simple CCN output stream. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>baseName</em>&nbsp;</td><td>name prefix under which to write content segments </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publisher</em>&nbsp;</td><td>key to use to sign the segments, if null, default for user is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>if null, new handle created with <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#abbbf4626e10f2d1a2addd1dc5b6a069f" title="Create a new CCNHandle, opening a new connection to the CCN network.">CCNHandle.open()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>if stream setup fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a94679af4692e2b24d438be27709d094d"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::CCNOutputStream" ref="a94679af4692e2b24d438be27709d094d" args="(ContentName baseName, ContentKeys keys, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.CCNOutputStream.CCNOutputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor for a simple CCN output stream. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>baseName</em>&nbsp;</td><td>name prefix under which to write content segments </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>keys with which to encrypt content, if null content either unencrypted or keys retrieved according to local policy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>if null, new handle created with <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#abbbf4626e10f2d1a2addd1dc5b6a069f" title="Create a new CCNHandle, opening a new connection to the CCN network.">CCNHandle.open()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>if stream setup fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2a82624c7f63ff2851a1a6ab3ec7797"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::CCNOutputStream" ref="ad2a82624c7f63ff2851a1a6ab3ec7797" args="(ContentName baseName, KeyLocator locator, PublisherPublicKeyDigest publisher, ContentKeys keys, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.CCNOutputStream.CCNOutputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>locator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor for a simple CCN output stream. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>baseName</em>&nbsp;</td><td>name prefix under which to write content segments </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locator</em>&nbsp;</td><td>key locator to use, if null, default for key is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publisher</em>&nbsp;</td><td>key to use to sign the segments, if null, default for user is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>keys with which to encrypt content, if null content either unencrypted or keys retrieved according to local policy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>if null, new handle created with <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#abbbf4626e10f2d1a2addd1dc5b6a069f" title="Create a new CCNHandle, opening a new connection to the CCN network.">CCNHandle.open()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>if stream setup fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f0f7d200ff4347b68fbf7b6f9067ec5"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::CCNOutputStream" ref="a1f0f7d200ff4347b68fbf7b6f9067ec5" args="(ContentName baseName, KeyLocator locator, PublisherPublicKeyDigest publisher, ContentType type, ContentKeys keys, CCNHandle handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.CCNOutputStream.CCNOutputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>locator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContentType&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html">CCNHandle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor for a simple CCN output stream. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>baseName</em>&nbsp;</td><td>name prefix under which to write content segments </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locator</em>&nbsp;</td><td>key locator to use, if null, default for key is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publisher</em>&nbsp;</td><td>key to use to sign the segments, if null, default for user is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>type to mark content (see ContentType), if null, DATA is used; if content encrypted, ENCR is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>keys with which to encrypt content, if null content either unencrypted or keys retrieved according to local policy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handle</em>&nbsp;</td><td>if null, new handle created with <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1_c_c_n_handle.html#abbbf4626e10f2d1a2addd1dc5b6a069f" title="Create a new CCNHandle, opening a new connection to the CCN network.">CCNHandle.open()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>if stream setup fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96abfba10af60d8e51af7dc178840a7a"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::CCNOutputStream" ref="a96abfba10af60d8e51af7dc178840a7a" args="(ContentName baseName, KeyLocator locator, PublisherPublicKeyDigest publisher, ContentType type, ContentKeys keys, CCNFlowControl flowControl)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.CCNOutputStream.CCNOutputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>locator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContentType&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html">CCNFlowControl</a>&nbsp;</td>
          <td class="paramname"> <em>flowControl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Low-level constructor used by clients that need to specify flow control behavior. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>baseName</em>&nbsp;</td><td>name prefix under which to write content segments </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locator</em>&nbsp;</td><td>key locator to use, if null, default for key is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publisher</em>&nbsp;</td><td>key to use to sign the segments, if null, default for user is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>type to mark content (see ContentType), if null, DATA is used; if content encrypted, ENCR is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>keys with which to encrypt content, if null content either unencrypted or keys retrieved according to local policy </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>flowControl</em>&nbsp;</td><td>flow controller used to buffer output content </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>if flow controller setup fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84aa0bf722a126566555afb1597a2e0c"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::CCNOutputStream" ref="a84aa0bf722a126566555afb1597a2e0c" args="(ContentName baseName, KeyLocator locator, PublisherPublicKeyDigest publisher, ContentType type, ContentKeys keys, CCNSegmenter segmenter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">org.ccnx.ccn.io.CCNOutputStream.CCNOutputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_content_name.html">ContentName</a>&nbsp;</td>
          <td class="paramname"> <em>baseName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_key_locator.html">KeyLocator</a>&nbsp;</td>
          <td class="paramname"> <em>locator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1protocol_1_1_publisher_public_key_digest.html">PublisherPublicKeyDigest</a>&nbsp;</td>
          <td class="paramname"> <em>publisher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContentType&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1security_1_1crypto_1_1_content_keys.html">ContentKeys</a>&nbsp;</td>
          <td class="paramname"> <em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_segmenter.html">CCNSegmenter</a>&nbsp;</td>
          <td class="paramname"> <em>segmenter</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Low-level constructor used by subclasses that need to specify segmenter behavior. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>baseName</em>&nbsp;</td><td>name prefix under which to write content segments </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>locator</em>&nbsp;</td><td>key locator to use, if null, default for key is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>publisher</em>&nbsp;</td><td>key to use to sign the segments, if null, default for user is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>type</em>&nbsp;</td><td>type to mark content (see ContentType), if null, DATA is used; if content encrypted, ENCR is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>keys</em>&nbsp;</td><td>the ContentKeys to use to encrypt, or null if unencrypted or access controlled (keys automatically retrieved) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>segmenter</em>&nbsp;</td><td>segmenter used to segment and sign content </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>if flow controller setup fails </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a40f3978a67ee41603b0fb1dc19c12741"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::closeNetworkData" ref="a40f3978a67ee41603b0fb1dc19c12741" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.CCNOutputStream.closeNetworkData </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws InvalidKeyException, SignatureException, NoSuchAlgorithmException, IOException, InterruptedException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Flush partial hanging block if we have one. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SignatureException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InterruptedException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_file_output_stream.html#a9425ee719d6960e139269fe7182dbd8f">org.ccnx.ccn.io.CCNFileOutputStream</a>.</p>

</div>
</div>
<a class="anchor" id="ac002eca85fabe9749eb5b74b51b1965a"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::flush" ref="ac002eca85fabe9749eb5b74b51b1965a" args="(boolean flushLastBlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.CCNOutputStream.flush </td>
          <td>(</td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>flushLastBlock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Internal flush. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flushLastBlock</em>&nbsp;</td><td>Should we flush the last (partial) block, or hold it back for it to be filled. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>on a variety of types of error. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0744cadfb3138aaacab118a05b409bee"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::flushToNetwork" ref="a0744cadfb3138aaacab118a05b409bee" args="(boolean flushLastBlock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">synchronized void org.ccnx.ccn.io.CCNOutputStream.flushToNetwork </td>
          <td>(</td>
          <td class="paramtype">boolean&nbsp;</td>
          <td class="paramname"> <em>flushLastBlock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws InvalidKeyException, SignatureException, NoSuchAlgorithmException, InterruptedException, IOException, InvalidAlgorithmParameterException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>flushLastBlock</em>&nbsp;</td><td>Do we flush a partially-filled last block in the current set of blocks? Not normally, we want to fill blocks. So if a user calls a manual flush(), we want to flush all full blocks, but not a last partial -- readers of this block-fragmented content (other streams make other sorts of fragments, this one is designed for files of same block size) expect all fragments but the last to be the same size. The only time we flush a last partial is on close(), when it is the last block of the data. This flag, passed in only by internal methods, tells us it's time to do that. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SignatureException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InterruptedException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidAlgorithmParameterException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p><p>XXX - Can the blockbuffers have holes? DKS: no. The blockCount argument to putMerkleTree is intended to tell it how many of the blockBuffers array it should touch (are non-null). If there are holes, there is a bigger problem.</p>
<p>Partial last block handling. If we are in the middle of writing a file, we only flush complete blocks; up to _blockOffset % <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#acb40d2ebaab380d8fad727bcf70d7822" title="Get segmentation block size.">getBlockSize()</a>. The only time we emit a 0-length block is if we've been told to flush the last block (i.e. we're closing the file) without having written anything at all. So for 0-length files we emit a single block with 0-length content (which has a Content element, but no contained BLOB).</p>
</p>

</div>
</div>
<a class="anchor" id="acb40d2ebaab380d8fad727bcf70d7822"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::getBlockSize" ref="acb40d2ebaab380d8fad727bcf70d7822" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int org.ccnx.ccn.io.CCNOutputStream.getBlockSize </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get segmentation block size. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>block size in bytes </dd></dl>

</div>
</div>
<a class="anchor" id="a06aed0453aadb2b634819b2d0d003f13"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::lengthWritten" ref="a06aed0453aadb2b634819b2d0d003f13" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long org.ccnx.ccn.io.CCNOutputStream.lengthWritten </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl class="return"><dt><b>Returns:</b></dt><dd>number of bytes that have been written on this stream. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7aa488dd2f0618cb1308b98f119acfc"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::setBlockSize" ref="ae7aa488dd2f0618cb1308b98f119acfc" args="(int blockSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">synchronized void org.ccnx.ccn.io.CCNOutputStream.setBlockSize </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>blockSize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the segmentation block size to use. </p>
<p>Constraints: needs to be a multiple of the likely encryption block size (which is, conservatively, 32 bytes). Default is 4096. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>blockSize</em>&nbsp;</td><td>in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f766e2d424cbf743029671ef2919858"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::startWrite" ref="a8f766e2d424cbf743029671ef2919858" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void org.ccnx.ccn.io.CCNOutputStream.startWrite </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td>  throws IOException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Override in subclasses that need to do something special with start writes (see <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1impl_1_1_c_c_n_flow_control.html#a8bfc829a1e6e762e4de36fdefea079e3" title="This is used to indicate that it should start a write for a stream with this name...">CCNFlowControl.startWrite(ContentName, Shape)</a>). </p>
<p>They should call this superclass method, though, to initialize keys (may need to move this later). </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_abstract_output_stream.html#a9e071a3379d803ed089602f5a6b84bc7">org.ccnx.ccn.io.CCNAbstractOutputStream</a>.</p>

</div>
</div>
<a class="anchor" id="a0216719604f1f1542814a9dccdc0ac20"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::writeToNetwork" ref="a0216719604f1f1542814a9dccdc0ac20" args="(byte[] buf, long offset, long len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">synchronized void org.ccnx.ccn.io.CCNOutputStream.writeToNetwork </td>
          <td>(</td>
          <td class="paramtype">byte[]&nbsp;</td>
          <td class="paramname"> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td>  throws IOException, InvalidKeyException, SignatureException, NoSuchAlgorithmException <code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Actually write bytes to the network. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>as in write(byte[], int, int) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>offset</em>&nbsp;</td><td>as in write(byte[], int, int) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>as in write(byte[]) </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>IOException</em>&nbsp;</td><td>on network errors </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>InvalidKeyException</em>&nbsp;</td><td>if we cannot encrypt content as specified </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SignatureException</em>&nbsp;</td><td>if we cannot sign content </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>NoSuchAlgorithmException</em>&nbsp;</td><td>if encryption requests invalid algorithm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a470e6741042f5b5ef64c11890a331678"></a><!-- doxytag: member="org::ccnx::ccn::io::CCNOutputStream::BLOCK_BUF_COUNT" ref="a470e6741042f5b5ef64c11890a331678" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">final int <a class="el" href="classorg_1_1ccnx_1_1ccn_1_1io_1_1_c_c_n_output_stream.html#a470e6741042f5b5ef64c11890a331678">org.ccnx.ccn.io.CCNOutputStream.BLOCK_BUF_COUNT</a> = 128<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Amount of data we keep around prior to forced flush, in terms of segmenter blocks. </p>
<p>We write to a limit lower than the maximum, to allow for expansion due to encryption. TODO calculate this dynamically based on the bulk signing method and overhead thereof </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/org/ccnx/ccn/io/CCNOutputStream.java</li>
</ul>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Thu Nov 4 13:34:28 2010 for Content-Centric Networking in Java by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
